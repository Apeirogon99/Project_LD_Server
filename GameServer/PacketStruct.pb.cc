#if defined(_MSC_VER)
        #pragma warning (disable:4018) // 'expression' : signed/unsigned mismatch
        #pragma warning (disable:4065) // switch statement contains 'default' but no 'case' labels
        #pragma warning (disable:4146) // unary minus operator applied to unsigned type, result still unsigned
        #pragma warning (disable:4244) // 'conversion' conversion from 'type1' to 'type2', possible loss of data
        #pragma warning (disable:4251) // 'identifier' : class 'type' needs to have dll-interface to be used byclient of class 'type2'
        #pragma warning (disable:4267) // 'var' : conversion from 'size_t' to 'type', possible loss of data
        #pragma warning (disable:4305) // 'identifier' : truncation from 'type1' to 'type2'
        #pragma warning (disable:4307) // 'operator' : integral constant overflow
        #pragma warning (disable:4309) // 'conversion' : truncation of constant value
        #pragma warning (disable:4334) // 'operator' : result of 32-bit shift implicitly converted to 64 bits (was64bit shift intended?)
        #pragma warning (disable:4355) // 'this' : used in base member initializer list
        #pragma warning (disable:4506) // no definition for inline function 'function'
        #pragma warning (disable:4800) // 'type' : forcing value to bool 'true' or 'false' (performance warning)
		 #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
        #pragma warning (disable:4996) // The compiler encountered a deprecated declaration.
        #pragma warning (disable:4125) // decimal digit terminates octal escape sequence
#endif

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PacketStruct.proto

#include "PacketStruct.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace Protocol {
PROTOBUF_CONSTEXPR SServerInfo::SServerInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.port_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SServerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SServerInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SServerInfoDefaultTypeInternal() {}
  union {
    SServerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SServerInfoDefaultTypeInternal _SServerInfo_default_instance_;
PROTOBUF_CONSTEXPR SCharacterAppearance::SCharacterAppearance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.race_)*/0
  , /*decltype(_impl_.seat_)*/0
  , /*decltype(_impl_.skin_color_)*/0
  , /*decltype(_impl_.hair_color_)*/0
  , /*decltype(_impl_.eye_color_)*/0
  , /*decltype(_impl_.eyebrow_color_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SCharacterAppearanceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SCharacterAppearanceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SCharacterAppearanceDefaultTypeInternal() {}
  union {
    SCharacterAppearance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SCharacterAppearanceDefaultTypeInternal _SCharacterAppearance_default_instance_;
PROTOBUF_CONSTEXPR SCharacterEqipment::SCharacterEqipment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hair_)*/0
  , /*decltype(_impl_.helmet_)*/0
  , /*decltype(_impl_.shoulders_)*/0
  , /*decltype(_impl_.chest_)*/0
  , /*decltype(_impl_.bracers_)*/0
  , /*decltype(_impl_.hands_)*/0
  , /*decltype(_impl_.pants_)*/0
  , /*decltype(_impl_.boots_)*/0
  , /*decltype(_impl_.weapon_l_)*/0
  , /*decltype(_impl_.weapon_r_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SCharacterEqipmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SCharacterEqipmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SCharacterEqipmentDefaultTypeInternal() {}
  union {
    SCharacterEqipment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SCharacterEqipmentDefaultTypeInternal _SCharacterEqipment_default_instance_;
PROTOBUF_CONSTEXPR SCharacterData::SCharacterData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.appearance_)*/nullptr
  , /*decltype(_impl_.eqipment_)*/nullptr
  , /*decltype(_impl_.level_)*/0
  , /*decltype(_impl_.experience_)*/0
  , /*decltype(_impl_.character_class_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SCharacterDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SCharacterDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SCharacterDataDefaultTypeInternal() {}
  union {
    SCharacterData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SCharacterDataDefaultTypeInternal _SCharacterData_default_instance_;
PROTOBUF_CONSTEXPR SVector::SVector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SVectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SVectorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SVectorDefaultTypeInternal() {}
  union {
    SVector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SVectorDefaultTypeInternal _SVector_default_instance_;
PROTOBUF_CONSTEXPR SVector2D::SVector2D(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SVector2DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SVector2DDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SVector2DDefaultTypeInternal() {}
  union {
    SVector2D _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SVector2DDefaultTypeInternal _SVector2D_default_instance_;
PROTOBUF_CONSTEXPR SVelocity::SVelocity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SVelocityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SVelocityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SVelocityDefaultTypeInternal() {}
  union {
    SVelocity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SVelocityDefaultTypeInternal _SVelocity_default_instance_;
PROTOBUF_CONSTEXPR SRotator::SRotator(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.roll_)*/0
  , /*decltype(_impl_.pitch_)*/0
  , /*decltype(_impl_.yaw_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SRotatorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SRotatorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SRotatorDefaultTypeInternal() {}
  union {
    SRotator _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SRotatorDefaultTypeInternal _SRotator_default_instance_;
PROTOBUF_CONSTEXPR STransform::STransform(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.location_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr
  , /*decltype(_impl_.scale_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct STransformDefaultTypeInternal {
  PROTOBUF_CONSTEXPR STransformDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~STransformDefaultTypeInternal() {}
  union {
    STransform _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 STransformDefaultTypeInternal _STransform_default_instance_;
PROTOBUF_CONSTEXPR SItem::SItem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.world_position_)*/nullptr
  , /*decltype(_impl_.inven_position_)*/nullptr
  , /*decltype(_impl_.object_id_)*/int64_t{0}
  , /*decltype(_impl_.item_code_)*/0
  , /*decltype(_impl_.rotation_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SItemDefaultTypeInternal() {}
  union {
    SItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SItemDefaultTypeInternal _SItem_default_instance_;
PROTOBUF_CONSTEXPR SEnemy::SEnemy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.location_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr
  , /*decltype(_impl_.state_)*/0
  , /*decltype(_impl_.hp_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SEnemyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SEnemyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SEnemyDefaultTypeInternal() {}
  union {
    SEnemy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SEnemyDefaultTypeInternal _SEnemy_default_instance_;
}  // namespace Protocol
static ::_pb::Metadata file_level_metadata_PacketStruct_2eproto[11];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_PacketStruct_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_PacketStruct_2eproto = nullptr;

const uint32_t TableStruct_PacketStruct_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::SServerInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::SServerInfo, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SServerInfo, _impl_.ip_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SServerInfo, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SServerInfo, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterAppearance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterAppearance, _impl_.race_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterAppearance, _impl_.seat_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterAppearance, _impl_.skin_color_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterAppearance, _impl_.hair_color_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterAppearance, _impl_.eye_color_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterAppearance, _impl_.eyebrow_color_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterEqipment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterEqipment, _impl_.hair_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterEqipment, _impl_.helmet_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterEqipment, _impl_.shoulders_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterEqipment, _impl_.chest_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterEqipment, _impl_.bracers_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterEqipment, _impl_.hands_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterEqipment, _impl_.pants_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterEqipment, _impl_.boots_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterEqipment, _impl_.weapon_l_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterEqipment, _impl_.weapon_r_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterData, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterData, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterData, _impl_.experience_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterData, _impl_.character_class_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterData, _impl_.appearance_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SCharacterData, _impl_.eqipment_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::SVector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::SVector, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SVector, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SVector, _impl_.z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::SVector2D, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::SVector2D, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SVector2D, _impl_.y_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::SVelocity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::SVelocity, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SVelocity, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SVelocity, _impl_.z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::SRotator, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::SRotator, _impl_.roll_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SRotator, _impl_.pitch_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SRotator, _impl_.yaw_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::STransform, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::STransform, _impl_.location_),
  PROTOBUF_FIELD_OFFSET(::Protocol::STransform, _impl_.rotation_),
  PROTOBUF_FIELD_OFFSET(::Protocol::STransform, _impl_.scale_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::SItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::SItem, _impl_.object_id_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SItem, _impl_.item_code_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SItem, _impl_.world_position_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SItem, _impl_.inven_position_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SItem, _impl_.rotation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::SEnemy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::SEnemy, _impl_.state_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SEnemy, _impl_.hp_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SEnemy, _impl_.location_),
  PROTOBUF_FIELD_OFFSET(::Protocol::SEnemy, _impl_.rotation_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::Protocol::SServerInfo)},
  { 10, -1, -1, sizeof(::Protocol::SCharacterAppearance)},
  { 22, -1, -1, sizeof(::Protocol::SCharacterEqipment)},
  { 38, -1, -1, sizeof(::Protocol::SCharacterData)},
  { 50, -1, -1, sizeof(::Protocol::SVector)},
  { 59, -1, -1, sizeof(::Protocol::SVector2D)},
  { 67, -1, -1, sizeof(::Protocol::SVelocity)},
  { 76, -1, -1, sizeof(::Protocol::SRotator)},
  { 85, -1, -1, sizeof(::Protocol::STransform)},
  { 94, -1, -1, sizeof(::Protocol::SItem)},
  { 105, -1, -1, sizeof(::Protocol::SEnemy)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::Protocol::_SServerInfo_default_instance_._instance,
  &::Protocol::_SCharacterAppearance_default_instance_._instance,
  &::Protocol::_SCharacterEqipment_default_instance_._instance,
  &::Protocol::_SCharacterData_default_instance_._instance,
  &::Protocol::_SVector_default_instance_._instance,
  &::Protocol::_SVector2D_default_instance_._instance,
  &::Protocol::_SVelocity_default_instance_._instance,
  &::Protocol::_SRotator_default_instance_._instance,
  &::Protocol::_STransform_default_instance_._instance,
  &::Protocol::_SItem_default_instance_._instance,
  &::Protocol::_SEnemy_default_instance_._instance,
};

const char descriptor_table_protodef_PacketStruct_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\022PacketStruct.proto\022\010Protocol\032\020PacketEn"
  "um.proto\"A\n\013SServerInfo\022\n\n\002id\030\001 \001(\005\022\n\n\002i"
  "p\030\002 \001(\014\022\014\n\004port\030\003 \001(\005\022\014\n\004name\030\004 \001(\014\"\225\001\n\024"
  "SCharacterAppearance\022\035\n\004race\030\001 \001(\0162\017.Pro"
  "tocol.ERace\022\014\n\004seat\030\002 \001(\005\022\022\n\nskin_color\030"
  "\003 \001(\005\022\022\n\nhair_color\030\004 \001(\005\022\021\n\teye_color\030\005"
  " \001(\005\022\025\n\reyebrow_color\030\006 \001(\005\"\266\001\n\022SCharact"
  "erEqipment\022\014\n\004hair\030\001 \001(\005\022\016\n\006helmet\030\002 \001(\005"
  "\022\021\n\tshoulders\030\003 \001(\005\022\r\n\005chest\030\004 \001(\005\022\017\n\007br"
  "acers\030\005 \001(\005\022\r\n\005hands\030\006 \001(\005\022\r\n\005pants\030\007 \001("
  "\005\022\r\n\005boots\030\010 \001(\005\022\020\n\010weapon_l\030\t \001(\005\022\020\n\010we"
  "apon_r\030\n \001(\005\"\331\001\n\016SCharacterData\022\014\n\004name\030"
  "\001 \001(\014\022\r\n\005level\030\002 \001(\005\022\022\n\nexperience\030\003 \001(\005"
  "\0222\n\017character_class\030\004 \001(\0162\031.Protocol.ECh"
  "aracterClass\0222\n\nappearance\030\005 \001(\0132\036.Proto"
  "col.SCharacterAppearance\022.\n\010eqipment\030\006 \001"
  "(\0132\034.Protocol.SCharacterEqipment\"*\n\007SVec"
  "tor\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\"!\n\t"
  "SVector2D\022\t\n\001x\030\001 \001(\005\022\t\n\001y\030\002 \001(\005\",\n\tSVelo"
  "city\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\"4\n"
  "\010SRotator\022\014\n\004roll\030\001 \001(\002\022\r\n\005pitch\030\002 \001(\002\022\013"
  "\n\003yaw\030\003 \001(\002\"y\n\nSTransform\022#\n\010location\030\001 "
  "\001(\0132\021.Protocol.SVector\022$\n\010rotation\030\002 \001(\013"
  "2\022.Protocol.SRotator\022 \n\005scale\030\003 \001(\0132\021.Pr"
  "otocol.SVector\"\227\001\n\005SItem\022\021\n\tobject_id\030\001 "
  "\001(\003\022\021\n\titem_code\030\002 \001(\005\022)\n\016world_position"
  "\030\003 \001(\0132\021.Protocol.SVector\022+\n\016inven_posit"
  "ion\030\004 \001(\0132\023.Protocol.SVector2D\022\020\n\010rotati"
  "on\030\005 \001(\005\"\205\001\n\006SEnemy\022$\n\005state\030\001 \001(\0162\025.Pro"
  "tocol.EEnemyState\022\n\n\002hp\030\002 \001(\002\022#\n\010locatio"
  "n\030\003 \001(\0132\021.Protocol.SVector\022$\n\010rotation\030\004"
  " \001(\0132\022.Protocol.SRotatorb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_PacketStruct_2eproto_deps[1] = {
  &::descriptor_table_PacketEnum_2eproto,
};
static ::_pbi::once_flag descriptor_table_PacketStruct_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_PacketStruct_2eproto = {
    false, false, 1272, descriptor_table_protodef_PacketStruct_2eproto,
    "PacketStruct.proto",
    &descriptor_table_PacketStruct_2eproto_once, descriptor_table_PacketStruct_2eproto_deps, 1, 11,
    schemas, file_default_instances, TableStruct_PacketStruct_2eproto::offsets,
    file_level_metadata_PacketStruct_2eproto, file_level_enum_descriptors_PacketStruct_2eproto,
    file_level_service_descriptors_PacketStruct_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_PacketStruct_2eproto_getter() {
  return &descriptor_table_PacketStruct_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_PacketStruct_2eproto(&descriptor_table_PacketStruct_2eproto);
namespace Protocol {

// ===================================================================

class SServerInfo::_Internal {
 public:
};

SServerInfo::SServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.SServerInfo)
}
SServerInfo::SServerInfo(const SServerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SServerInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ip_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.id_){}
    , decltype(_impl_.port_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ip().empty()) {
    _this->_impl_.ip_.Set(from._internal_ip(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.port_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.port_));
  // @@protoc_insertion_point(copy_constructor:Protocol.SServerInfo)
}

inline void SServerInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ip_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.port_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SServerInfo::~SServerInfo() {
  // @@protoc_insertion_point(destructor:Protocol.SServerInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SServerInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ip_.Destroy();
  _impl_.name_.Destroy();
}

void SServerInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SServerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.SServerInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ip_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.port_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.port_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SServerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SServerInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.SServerInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // bytes ip = 2;
  if (!this->_internal_ip().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_ip(), target);
  }

  // int32 port = 3;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_port(), target);
  }

  // bytes name = 4;
  if (!this->_internal_name().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.SServerInfo)
  return target;
}

size_t SServerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.SServerInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes ip = 2;
  if (!this->_internal_ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ip());
  }

  // bytes name = 4;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_name());
  }

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  // int32 port = 3;
  if (this->_internal_port() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SServerInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SServerInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SServerInfo::GetClassData() const { return &_class_data_; }


void SServerInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SServerInfo*>(&to_msg);
  auto& from = static_cast<const SServerInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.SServerInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ip().empty()) {
    _this->_internal_set_ip(from._internal_ip());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_port() != 0) {
    _this->_internal_set_port(from._internal_port());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SServerInfo::CopyFrom(const SServerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.SServerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SServerInfo::IsInitialized() const {
  return true;
}

void SServerInfo::InternalSwap(SServerInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_, lhs_arena,
      &other->_impl_.ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SServerInfo, _impl_.port_)
      + sizeof(SServerInfo::_impl_.port_)
      - PROTOBUF_FIELD_OFFSET(SServerInfo, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SServerInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_PacketStruct_2eproto_getter, &descriptor_table_PacketStruct_2eproto_once,
      file_level_metadata_PacketStruct_2eproto[0]);
}

// ===================================================================

class SCharacterAppearance::_Internal {
 public:
};

SCharacterAppearance::SCharacterAppearance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.SCharacterAppearance)
}
SCharacterAppearance::SCharacterAppearance(const SCharacterAppearance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SCharacterAppearance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.race_){}
    , decltype(_impl_.seat_){}
    , decltype(_impl_.skin_color_){}
    , decltype(_impl_.hair_color_){}
    , decltype(_impl_.eye_color_){}
    , decltype(_impl_.eyebrow_color_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.race_, &from._impl_.race_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.eyebrow_color_) -
    reinterpret_cast<char*>(&_impl_.race_)) + sizeof(_impl_.eyebrow_color_));
  // @@protoc_insertion_point(copy_constructor:Protocol.SCharacterAppearance)
}

inline void SCharacterAppearance::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.race_){0}
    , decltype(_impl_.seat_){0}
    , decltype(_impl_.skin_color_){0}
    , decltype(_impl_.hair_color_){0}
    , decltype(_impl_.eye_color_){0}
    , decltype(_impl_.eyebrow_color_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SCharacterAppearance::~SCharacterAppearance() {
  // @@protoc_insertion_point(destructor:Protocol.SCharacterAppearance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SCharacterAppearance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SCharacterAppearance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SCharacterAppearance::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.SCharacterAppearance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.race_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.eyebrow_color_) -
      reinterpret_cast<char*>(&_impl_.race_)) + sizeof(_impl_.eyebrow_color_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SCharacterAppearance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.ERace race = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_race(static_cast<::Protocol::ERace>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 seat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.seat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 skin_color = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.skin_color_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 hair_color = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.hair_color_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 eye_color = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.eye_color_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 eyebrow_color = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.eyebrow_color_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SCharacterAppearance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.SCharacterAppearance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.ERace race = 1;
  if (this->_internal_race() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_race(), target);
  }

  // int32 seat = 2;
  if (this->_internal_seat() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_seat(), target);
  }

  // int32 skin_color = 3;
  if (this->_internal_skin_color() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_skin_color(), target);
  }

  // int32 hair_color = 4;
  if (this->_internal_hair_color() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_hair_color(), target);
  }

  // int32 eye_color = 5;
  if (this->_internal_eye_color() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_eye_color(), target);
  }

  // int32 eyebrow_color = 6;
  if (this->_internal_eyebrow_color() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_eyebrow_color(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.SCharacterAppearance)
  return target;
}

size_t SCharacterAppearance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.SCharacterAppearance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.ERace race = 1;
  if (this->_internal_race() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_race());
  }

  // int32 seat = 2;
  if (this->_internal_seat() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_seat());
  }

  // int32 skin_color = 3;
  if (this->_internal_skin_color() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_skin_color());
  }

  // int32 hair_color = 4;
  if (this->_internal_hair_color() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hair_color());
  }

  // int32 eye_color = 5;
  if (this->_internal_eye_color() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eye_color());
  }

  // int32 eyebrow_color = 6;
  if (this->_internal_eyebrow_color() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eyebrow_color());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SCharacterAppearance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SCharacterAppearance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SCharacterAppearance::GetClassData() const { return &_class_data_; }


void SCharacterAppearance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SCharacterAppearance*>(&to_msg);
  auto& from = static_cast<const SCharacterAppearance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.SCharacterAppearance)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_race() != 0) {
    _this->_internal_set_race(from._internal_race());
  }
  if (from._internal_seat() != 0) {
    _this->_internal_set_seat(from._internal_seat());
  }
  if (from._internal_skin_color() != 0) {
    _this->_internal_set_skin_color(from._internal_skin_color());
  }
  if (from._internal_hair_color() != 0) {
    _this->_internal_set_hair_color(from._internal_hair_color());
  }
  if (from._internal_eye_color() != 0) {
    _this->_internal_set_eye_color(from._internal_eye_color());
  }
  if (from._internal_eyebrow_color() != 0) {
    _this->_internal_set_eyebrow_color(from._internal_eyebrow_color());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SCharacterAppearance::CopyFrom(const SCharacterAppearance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.SCharacterAppearance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SCharacterAppearance::IsInitialized() const {
  return true;
}

void SCharacterAppearance::InternalSwap(SCharacterAppearance* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SCharacterAppearance, _impl_.eyebrow_color_)
      + sizeof(SCharacterAppearance::_impl_.eyebrow_color_)
      - PROTOBUF_FIELD_OFFSET(SCharacterAppearance, _impl_.race_)>(
          reinterpret_cast<char*>(&_impl_.race_),
          reinterpret_cast<char*>(&other->_impl_.race_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SCharacterAppearance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_PacketStruct_2eproto_getter, &descriptor_table_PacketStruct_2eproto_once,
      file_level_metadata_PacketStruct_2eproto[1]);
}

// ===================================================================

class SCharacterEqipment::_Internal {
 public:
};

SCharacterEqipment::SCharacterEqipment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.SCharacterEqipment)
}
SCharacterEqipment::SCharacterEqipment(const SCharacterEqipment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SCharacterEqipment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hair_){}
    , decltype(_impl_.helmet_){}
    , decltype(_impl_.shoulders_){}
    , decltype(_impl_.chest_){}
    , decltype(_impl_.bracers_){}
    , decltype(_impl_.hands_){}
    , decltype(_impl_.pants_){}
    , decltype(_impl_.boots_){}
    , decltype(_impl_.weapon_l_){}
    , decltype(_impl_.weapon_r_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.hair_, &from._impl_.hair_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.weapon_r_) -
    reinterpret_cast<char*>(&_impl_.hair_)) + sizeof(_impl_.weapon_r_));
  // @@protoc_insertion_point(copy_constructor:Protocol.SCharacterEqipment)
}

inline void SCharacterEqipment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hair_){0}
    , decltype(_impl_.helmet_){0}
    , decltype(_impl_.shoulders_){0}
    , decltype(_impl_.chest_){0}
    , decltype(_impl_.bracers_){0}
    , decltype(_impl_.hands_){0}
    , decltype(_impl_.pants_){0}
    , decltype(_impl_.boots_){0}
    , decltype(_impl_.weapon_l_){0}
    , decltype(_impl_.weapon_r_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SCharacterEqipment::~SCharacterEqipment() {
  // @@protoc_insertion_point(destructor:Protocol.SCharacterEqipment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SCharacterEqipment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SCharacterEqipment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SCharacterEqipment::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.SCharacterEqipment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.hair_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.weapon_r_) -
      reinterpret_cast<char*>(&_impl_.hair_)) + sizeof(_impl_.weapon_r_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SCharacterEqipment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 hair = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hair_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 helmet = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.helmet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 shoulders = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.shoulders_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 chest = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.chest_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 bracers = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.bracers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 hands = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.hands_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 pants = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.pants_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 boots = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.boots_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 weapon_l = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.weapon_l_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 weapon_r = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.weapon_r_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SCharacterEqipment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.SCharacterEqipment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 hair = 1;
  if (this->_internal_hair() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_hair(), target);
  }

  // int32 helmet = 2;
  if (this->_internal_helmet() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_helmet(), target);
  }

  // int32 shoulders = 3;
  if (this->_internal_shoulders() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_shoulders(), target);
  }

  // int32 chest = 4;
  if (this->_internal_chest() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_chest(), target);
  }

  // int32 bracers = 5;
  if (this->_internal_bracers() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_bracers(), target);
  }

  // int32 hands = 6;
  if (this->_internal_hands() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_hands(), target);
  }

  // int32 pants = 7;
  if (this->_internal_pants() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_pants(), target);
  }

  // int32 boots = 8;
  if (this->_internal_boots() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_boots(), target);
  }

  // int32 weapon_l = 9;
  if (this->_internal_weapon_l() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_weapon_l(), target);
  }

  // int32 weapon_r = 10;
  if (this->_internal_weapon_r() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_weapon_r(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.SCharacterEqipment)
  return target;
}

size_t SCharacterEqipment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.SCharacterEqipment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 hair = 1;
  if (this->_internal_hair() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hair());
  }

  // int32 helmet = 2;
  if (this->_internal_helmet() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_helmet());
  }

  // int32 shoulders = 3;
  if (this->_internal_shoulders() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_shoulders());
  }

  // int32 chest = 4;
  if (this->_internal_chest() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_chest());
  }

  // int32 bracers = 5;
  if (this->_internal_bracers() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bracers());
  }

  // int32 hands = 6;
  if (this->_internal_hands() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hands());
  }

  // int32 pants = 7;
  if (this->_internal_pants() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pants());
  }

  // int32 boots = 8;
  if (this->_internal_boots() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_boots());
  }

  // int32 weapon_l = 9;
  if (this->_internal_weapon_l() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_weapon_l());
  }

  // int32 weapon_r = 10;
  if (this->_internal_weapon_r() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_weapon_r());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SCharacterEqipment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SCharacterEqipment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SCharacterEqipment::GetClassData() const { return &_class_data_; }


void SCharacterEqipment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SCharacterEqipment*>(&to_msg);
  auto& from = static_cast<const SCharacterEqipment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.SCharacterEqipment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_hair() != 0) {
    _this->_internal_set_hair(from._internal_hair());
  }
  if (from._internal_helmet() != 0) {
    _this->_internal_set_helmet(from._internal_helmet());
  }
  if (from._internal_shoulders() != 0) {
    _this->_internal_set_shoulders(from._internal_shoulders());
  }
  if (from._internal_chest() != 0) {
    _this->_internal_set_chest(from._internal_chest());
  }
  if (from._internal_bracers() != 0) {
    _this->_internal_set_bracers(from._internal_bracers());
  }
  if (from._internal_hands() != 0) {
    _this->_internal_set_hands(from._internal_hands());
  }
  if (from._internal_pants() != 0) {
    _this->_internal_set_pants(from._internal_pants());
  }
  if (from._internal_boots() != 0) {
    _this->_internal_set_boots(from._internal_boots());
  }
  if (from._internal_weapon_l() != 0) {
    _this->_internal_set_weapon_l(from._internal_weapon_l());
  }
  if (from._internal_weapon_r() != 0) {
    _this->_internal_set_weapon_r(from._internal_weapon_r());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SCharacterEqipment::CopyFrom(const SCharacterEqipment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.SCharacterEqipment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SCharacterEqipment::IsInitialized() const {
  return true;
}

void SCharacterEqipment::InternalSwap(SCharacterEqipment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SCharacterEqipment, _impl_.weapon_r_)
      + sizeof(SCharacterEqipment::_impl_.weapon_r_)
      - PROTOBUF_FIELD_OFFSET(SCharacterEqipment, _impl_.hair_)>(
          reinterpret_cast<char*>(&_impl_.hair_),
          reinterpret_cast<char*>(&other->_impl_.hair_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SCharacterEqipment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_PacketStruct_2eproto_getter, &descriptor_table_PacketStruct_2eproto_once,
      file_level_metadata_PacketStruct_2eproto[2]);
}

// ===================================================================

class SCharacterData::_Internal {
 public:
  static const ::Protocol::SCharacterAppearance& appearance(const SCharacterData* msg);
  static const ::Protocol::SCharacterEqipment& eqipment(const SCharacterData* msg);
};

const ::Protocol::SCharacterAppearance&
SCharacterData::_Internal::appearance(const SCharacterData* msg) {
  return *msg->_impl_.appearance_;
}
const ::Protocol::SCharacterEqipment&
SCharacterData::_Internal::eqipment(const SCharacterData* msg) {
  return *msg->_impl_.eqipment_;
}
SCharacterData::SCharacterData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.SCharacterData)
}
SCharacterData::SCharacterData(const SCharacterData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SCharacterData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.appearance_){nullptr}
    , decltype(_impl_.eqipment_){nullptr}
    , decltype(_impl_.level_){}
    , decltype(_impl_.experience_){}
    , decltype(_impl_.character_class_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_appearance()) {
    _this->_impl_.appearance_ = new ::Protocol::SCharacterAppearance(*from._impl_.appearance_);
  }
  if (from._internal_has_eqipment()) {
    _this->_impl_.eqipment_ = new ::Protocol::SCharacterEqipment(*from._impl_.eqipment_);
  }
  ::memcpy(&_impl_.level_, &from._impl_.level_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.character_class_) -
    reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.character_class_));
  // @@protoc_insertion_point(copy_constructor:Protocol.SCharacterData)
}

inline void SCharacterData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.appearance_){nullptr}
    , decltype(_impl_.eqipment_){nullptr}
    , decltype(_impl_.level_){0}
    , decltype(_impl_.experience_){0}
    , decltype(_impl_.character_class_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SCharacterData::~SCharacterData() {
  // @@protoc_insertion_point(destructor:Protocol.SCharacterData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SCharacterData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.appearance_;
  if (this != internal_default_instance()) delete _impl_.eqipment_;
}

void SCharacterData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SCharacterData::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.SCharacterData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.appearance_ != nullptr) {
    delete _impl_.appearance_;
  }
  _impl_.appearance_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.eqipment_ != nullptr) {
    delete _impl_.eqipment_;
  }
  _impl_.eqipment_ = nullptr;
  ::memset(&_impl_.level_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.character_class_) -
      reinterpret_cast<char*>(&_impl_.level_)) + sizeof(_impl_.character_class_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SCharacterData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 experience = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.experience_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.ECharacterClass character_class = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_character_class(static_cast<::Protocol::ECharacterClass>(val));
        } else
          goto handle_unusual;
        continue;
      // .Protocol.SCharacterAppearance appearance = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_appearance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.SCharacterEqipment eqipment = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_eqipment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SCharacterData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.SCharacterData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes name = 1;
  if (!this->_internal_name().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_name(), target);
  }

  // int32 level = 2;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_level(), target);
  }

  // int32 experience = 3;
  if (this->_internal_experience() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_experience(), target);
  }

  // .Protocol.ECharacterClass character_class = 4;
  if (this->_internal_character_class() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_character_class(), target);
  }

  // .Protocol.SCharacterAppearance appearance = 5;
  if (this->_internal_has_appearance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::appearance(this),
        _Internal::appearance(this).GetCachedSize(), target, stream);
  }

  // .Protocol.SCharacterEqipment eqipment = 6;
  if (this->_internal_has_eqipment()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::eqipment(this),
        _Internal::eqipment(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.SCharacterData)
  return target;
}

size_t SCharacterData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.SCharacterData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_name());
  }

  // .Protocol.SCharacterAppearance appearance = 5;
  if (this->_internal_has_appearance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.appearance_);
  }

  // .Protocol.SCharacterEqipment eqipment = 6;
  if (this->_internal_has_eqipment()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.eqipment_);
  }

  // int32 level = 2;
  if (this->_internal_level() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_level());
  }

  // int32 experience = 3;
  if (this->_internal_experience() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_experience());
  }

  // .Protocol.ECharacterClass character_class = 4;
  if (this->_internal_character_class() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_character_class());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SCharacterData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SCharacterData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SCharacterData::GetClassData() const { return &_class_data_; }


void SCharacterData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SCharacterData*>(&to_msg);
  auto& from = static_cast<const SCharacterData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.SCharacterData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_appearance()) {
    _this->_internal_mutable_appearance()->::Protocol::SCharacterAppearance::MergeFrom(
        from._internal_appearance());
  }
  if (from._internal_has_eqipment()) {
    _this->_internal_mutable_eqipment()->::Protocol::SCharacterEqipment::MergeFrom(
        from._internal_eqipment());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  if (from._internal_experience() != 0) {
    _this->_internal_set_experience(from._internal_experience());
  }
  if (from._internal_character_class() != 0) {
    _this->_internal_set_character_class(from._internal_character_class());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SCharacterData::CopyFrom(const SCharacterData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.SCharacterData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SCharacterData::IsInitialized() const {
  return true;
}

void SCharacterData::InternalSwap(SCharacterData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SCharacterData, _impl_.character_class_)
      + sizeof(SCharacterData::_impl_.character_class_)
      - PROTOBUF_FIELD_OFFSET(SCharacterData, _impl_.appearance_)>(
          reinterpret_cast<char*>(&_impl_.appearance_),
          reinterpret_cast<char*>(&other->_impl_.appearance_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SCharacterData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_PacketStruct_2eproto_getter, &descriptor_table_PacketStruct_2eproto_once,
      file_level_metadata_PacketStruct_2eproto[3]);
}

// ===================================================================

class SVector::_Internal {
 public:
};

SVector::SVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.SVector)
}
SVector::SVector(const SVector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SVector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:Protocol.SVector)
}

inline void SVector::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SVector::~SVector() {
  // @@protoc_insertion_point(destructor:Protocol.SVector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SVector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SVector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SVector::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.SVector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SVector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SVector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.SVector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.SVector)
  return target;
}

size_t SVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.SVector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SVector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SVector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SVector::GetClassData() const { return &_class_data_; }


void SVector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SVector*>(&to_msg);
  auto& from = static_cast<const SVector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.SVector)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SVector::CopyFrom(const SVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.SVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SVector::IsInitialized() const {
  return true;
}

void SVector::InternalSwap(SVector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SVector, _impl_.z_)
      + sizeof(SVector::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(SVector, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SVector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_PacketStruct_2eproto_getter, &descriptor_table_PacketStruct_2eproto_once,
      file_level_metadata_PacketStruct_2eproto[4]);
}

// ===================================================================

class SVector2D::_Internal {
 public:
};

SVector2D::SVector2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.SVector2D)
}
SVector2D::SVector2D(const SVector2D& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SVector2D* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:Protocol.SVector2D)
}

inline void SVector2D::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SVector2D::~SVector2D() {
  // @@protoc_insertion_point(destructor:Protocol.SVector2D)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SVector2D::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SVector2D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SVector2D::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.SVector2D)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SVector2D::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SVector2D::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.SVector2D)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 x = 1;
  if (this->_internal_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // int32 y = 2;
  if (this->_internal_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.SVector2D)
  return target;
}

size_t SVector2D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.SVector2D)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 x = 1;
  if (this->_internal_x() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
  }

  // int32 y = 2;
  if (this->_internal_y() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SVector2D::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SVector2D::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SVector2D::GetClassData() const { return &_class_data_; }


void SVector2D::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SVector2D*>(&to_msg);
  auto& from = static_cast<const SVector2D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.SVector2D)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_x() != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  if (from._internal_y() != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SVector2D::CopyFrom(const SVector2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.SVector2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SVector2D::IsInitialized() const {
  return true;
}

void SVector2D::InternalSwap(SVector2D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SVector2D, _impl_.y_)
      + sizeof(SVector2D::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(SVector2D, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SVector2D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_PacketStruct_2eproto_getter, &descriptor_table_PacketStruct_2eproto_once,
      file_level_metadata_PacketStruct_2eproto[5]);
}

// ===================================================================

class SVelocity::_Internal {
 public:
};

SVelocity::SVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.SVelocity)
}
SVelocity::SVelocity(const SVelocity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SVelocity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:Protocol.SVelocity)
}

inline void SVelocity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SVelocity::~SVelocity() {
  // @@protoc_insertion_point(destructor:Protocol.SVelocity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SVelocity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SVelocity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SVelocity::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.SVelocity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SVelocity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SVelocity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.SVelocity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.SVelocity)
  return target;
}

size_t SVelocity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.SVelocity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SVelocity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SVelocity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SVelocity::GetClassData() const { return &_class_data_; }


void SVelocity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SVelocity*>(&to_msg);
  auto& from = static_cast<const SVelocity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.SVelocity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SVelocity::CopyFrom(const SVelocity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.SVelocity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SVelocity::IsInitialized() const {
  return true;
}

void SVelocity::InternalSwap(SVelocity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SVelocity, _impl_.z_)
      + sizeof(SVelocity::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(SVelocity, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SVelocity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_PacketStruct_2eproto_getter, &descriptor_table_PacketStruct_2eproto_once,
      file_level_metadata_PacketStruct_2eproto[6]);
}

// ===================================================================

class SRotator::_Internal {
 public:
};

SRotator::SRotator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.SRotator)
}
SRotator::SRotator(const SRotator& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SRotator* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.roll_){}
    , decltype(_impl_.pitch_){}
    , decltype(_impl_.yaw_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.roll_, &from._impl_.roll_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.yaw_) -
    reinterpret_cast<char*>(&_impl_.roll_)) + sizeof(_impl_.yaw_));
  // @@protoc_insertion_point(copy_constructor:Protocol.SRotator)
}

inline void SRotator::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.roll_){0}
    , decltype(_impl_.pitch_){0}
    , decltype(_impl_.yaw_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SRotator::~SRotator() {
  // @@protoc_insertion_point(destructor:Protocol.SRotator)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SRotator::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SRotator::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SRotator::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.SRotator)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.roll_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.yaw_) -
      reinterpret_cast<char*>(&_impl_.roll_)) + sizeof(_impl_.yaw_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SRotator::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float roll = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.roll_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float pitch = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.pitch_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float yaw = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.yaw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SRotator::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.SRotator)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float roll = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_roll = this->_internal_roll();
  uint32_t raw_roll;
  memcpy(&raw_roll, &tmp_roll, sizeof(tmp_roll));
  if (raw_roll != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_roll(), target);
  }

  // float pitch = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = this->_internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_pitch(), target);
  }

  // float yaw = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = this->_internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_yaw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.SRotator)
  return target;
}

size_t SRotator::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.SRotator)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float roll = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_roll = this->_internal_roll();
  uint32_t raw_roll;
  memcpy(&raw_roll, &tmp_roll, sizeof(tmp_roll));
  if (raw_roll != 0) {
    total_size += 1 + 4;
  }

  // float pitch = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = this->_internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    total_size += 1 + 4;
  }

  // float yaw = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = this->_internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SRotator::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SRotator::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SRotator::GetClassData() const { return &_class_data_; }


void SRotator::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SRotator*>(&to_msg);
  auto& from = static_cast<const SRotator&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.SRotator)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_roll = from._internal_roll();
  uint32_t raw_roll;
  memcpy(&raw_roll, &tmp_roll, sizeof(tmp_roll));
  if (raw_roll != 0) {
    _this->_internal_set_roll(from._internal_roll());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = from._internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    _this->_internal_set_pitch(from._internal_pitch());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = from._internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    _this->_internal_set_yaw(from._internal_yaw());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SRotator::CopyFrom(const SRotator& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.SRotator)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SRotator::IsInitialized() const {
  return true;
}

void SRotator::InternalSwap(SRotator* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SRotator, _impl_.yaw_)
      + sizeof(SRotator::_impl_.yaw_)
      - PROTOBUF_FIELD_OFFSET(SRotator, _impl_.roll_)>(
          reinterpret_cast<char*>(&_impl_.roll_),
          reinterpret_cast<char*>(&other->_impl_.roll_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SRotator::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_PacketStruct_2eproto_getter, &descriptor_table_PacketStruct_2eproto_once,
      file_level_metadata_PacketStruct_2eproto[7]);
}

// ===================================================================

class STransform::_Internal {
 public:
  static const ::Protocol::SVector& location(const STransform* msg);
  static const ::Protocol::SRotator& rotation(const STransform* msg);
  static const ::Protocol::SVector& scale(const STransform* msg);
};

const ::Protocol::SVector&
STransform::_Internal::location(const STransform* msg) {
  return *msg->_impl_.location_;
}
const ::Protocol::SRotator&
STransform::_Internal::rotation(const STransform* msg) {
  return *msg->_impl_.rotation_;
}
const ::Protocol::SVector&
STransform::_Internal::scale(const STransform* msg) {
  return *msg->_impl_.scale_;
}
STransform::STransform(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.STransform)
}
STransform::STransform(const STransform& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  STransform* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.location_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.scale_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_location()) {
    _this->_impl_.location_ = new ::Protocol::SVector(*from._impl_.location_);
  }
  if (from._internal_has_rotation()) {
    _this->_impl_.rotation_ = new ::Protocol::SRotator(*from._impl_.rotation_);
  }
  if (from._internal_has_scale()) {
    _this->_impl_.scale_ = new ::Protocol::SVector(*from._impl_.scale_);
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.STransform)
}

inline void STransform::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.location_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.scale_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

STransform::~STransform() {
  // @@protoc_insertion_point(destructor:Protocol.STransform)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void STransform::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.location_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
  if (this != internal_default_instance()) delete _impl_.scale_;
}

void STransform::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void STransform::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.STransform)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.location_ != nullptr) {
    delete _impl_.location_;
  }
  _impl_.location_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.scale_ != nullptr) {
    delete _impl_.scale_;
  }
  _impl_.scale_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* STransform::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.SVector location = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_location(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.SRotator rotation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.SVector scale = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_scale(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* STransform::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.STransform)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.SVector location = 1;
  if (this->_internal_has_location()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::location(this),
        _Internal::location(this).GetCachedSize(), target, stream);
  }

  // .Protocol.SRotator rotation = 2;
  if (this->_internal_has_rotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  // .Protocol.SVector scale = 3;
  if (this->_internal_has_scale()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::scale(this),
        _Internal::scale(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.STransform)
  return target;
}

size_t STransform::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.STransform)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.SVector location = 1;
  if (this->_internal_has_location()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.location_);
  }

  // .Protocol.SRotator rotation = 2;
  if (this->_internal_has_rotation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rotation_);
  }

  // .Protocol.SVector scale = 3;
  if (this->_internal_has_scale()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.scale_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData STransform::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    STransform::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*STransform::GetClassData() const { return &_class_data_; }


void STransform::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<STransform*>(&to_msg);
  auto& from = static_cast<const STransform&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.STransform)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_location()) {
    _this->_internal_mutable_location()->::Protocol::SVector::MergeFrom(
        from._internal_location());
  }
  if (from._internal_has_rotation()) {
    _this->_internal_mutable_rotation()->::Protocol::SRotator::MergeFrom(
        from._internal_rotation());
  }
  if (from._internal_has_scale()) {
    _this->_internal_mutable_scale()->::Protocol::SVector::MergeFrom(
        from._internal_scale());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void STransform::CopyFrom(const STransform& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.STransform)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool STransform::IsInitialized() const {
  return true;
}

void STransform::InternalSwap(STransform* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(STransform, _impl_.scale_)
      + sizeof(STransform::_impl_.scale_)
      - PROTOBUF_FIELD_OFFSET(STransform, _impl_.location_)>(
          reinterpret_cast<char*>(&_impl_.location_),
          reinterpret_cast<char*>(&other->_impl_.location_));
}

::PROTOBUF_NAMESPACE_ID::Metadata STransform::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_PacketStruct_2eproto_getter, &descriptor_table_PacketStruct_2eproto_once,
      file_level_metadata_PacketStruct_2eproto[8]);
}

// ===================================================================

class SItem::_Internal {
 public:
  static const ::Protocol::SVector& world_position(const SItem* msg);
  static const ::Protocol::SVector2D& inven_position(const SItem* msg);
};

const ::Protocol::SVector&
SItem::_Internal::world_position(const SItem* msg) {
  return *msg->_impl_.world_position_;
}
const ::Protocol::SVector2D&
SItem::_Internal::inven_position(const SItem* msg) {
  return *msg->_impl_.inven_position_;
}
SItem::SItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.SItem)
}
SItem::SItem(const SItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SItem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.world_position_){nullptr}
    , decltype(_impl_.inven_position_){nullptr}
    , decltype(_impl_.object_id_){}
    , decltype(_impl_.item_code_){}
    , decltype(_impl_.rotation_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_world_position()) {
    _this->_impl_.world_position_ = new ::Protocol::SVector(*from._impl_.world_position_);
  }
  if (from._internal_has_inven_position()) {
    _this->_impl_.inven_position_ = new ::Protocol::SVector2D(*from._impl_.inven_position_);
  }
  ::memcpy(&_impl_.object_id_, &from._impl_.object_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rotation_) -
    reinterpret_cast<char*>(&_impl_.object_id_)) + sizeof(_impl_.rotation_));
  // @@protoc_insertion_point(copy_constructor:Protocol.SItem)
}

inline void SItem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.world_position_){nullptr}
    , decltype(_impl_.inven_position_){nullptr}
    , decltype(_impl_.object_id_){int64_t{0}}
    , decltype(_impl_.item_code_){0}
    , decltype(_impl_.rotation_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SItem::~SItem() {
  // @@protoc_insertion_point(destructor:Protocol.SItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.world_position_;
  if (this != internal_default_instance()) delete _impl_.inven_position_;
}

void SItem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SItem::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.SItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.world_position_ != nullptr) {
    delete _impl_.world_position_;
  }
  _impl_.world_position_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.inven_position_ != nullptr) {
    delete _impl_.inven_position_;
  }
  _impl_.inven_position_ = nullptr;
  ::memset(&_impl_.object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.rotation_) -
      reinterpret_cast<char*>(&_impl_.object_id_)) + sizeof(_impl_.rotation_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 object_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.object_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 item_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.item_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.SVector world_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_world_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.SVector2D inven_position = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_inven_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 rotation = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.SItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 object_id = 1;
  if (this->_internal_object_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_object_id(), target);
  }

  // int32 item_code = 2;
  if (this->_internal_item_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_item_code(), target);
  }

  // .Protocol.SVector world_position = 3;
  if (this->_internal_has_world_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::world_position(this),
        _Internal::world_position(this).GetCachedSize(), target, stream);
  }

  // .Protocol.SVector2D inven_position = 4;
  if (this->_internal_has_inven_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::inven_position(this),
        _Internal::inven_position(this).GetCachedSize(), target, stream);
  }

  // int32 rotation = 5;
  if (this->_internal_rotation() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_rotation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.SItem)
  return target;
}

size_t SItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.SItem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.SVector world_position = 3;
  if (this->_internal_has_world_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.world_position_);
  }

  // .Protocol.SVector2D inven_position = 4;
  if (this->_internal_has_inven_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.inven_position_);
  }

  // int64 object_id = 1;
  if (this->_internal_object_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_object_id());
  }

  // int32 item_code = 2;
  if (this->_internal_item_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_item_code());
  }

  // int32 rotation = 5;
  if (this->_internal_rotation() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rotation());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SItem::GetClassData() const { return &_class_data_; }


void SItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SItem*>(&to_msg);
  auto& from = static_cast<const SItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.SItem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_world_position()) {
    _this->_internal_mutable_world_position()->::Protocol::SVector::MergeFrom(
        from._internal_world_position());
  }
  if (from._internal_has_inven_position()) {
    _this->_internal_mutable_inven_position()->::Protocol::SVector2D::MergeFrom(
        from._internal_inven_position());
  }
  if (from._internal_object_id() != 0) {
    _this->_internal_set_object_id(from._internal_object_id());
  }
  if (from._internal_item_code() != 0) {
    _this->_internal_set_item_code(from._internal_item_code());
  }
  if (from._internal_rotation() != 0) {
    _this->_internal_set_rotation(from._internal_rotation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SItem::CopyFrom(const SItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.SItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SItem::IsInitialized() const {
  return true;
}

void SItem::InternalSwap(SItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SItem, _impl_.rotation_)
      + sizeof(SItem::_impl_.rotation_)
      - PROTOBUF_FIELD_OFFSET(SItem, _impl_.world_position_)>(
          reinterpret_cast<char*>(&_impl_.world_position_),
          reinterpret_cast<char*>(&other->_impl_.world_position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_PacketStruct_2eproto_getter, &descriptor_table_PacketStruct_2eproto_once,
      file_level_metadata_PacketStruct_2eproto[9]);
}

// ===================================================================

class SEnemy::_Internal {
 public:
  static const ::Protocol::SVector& location(const SEnemy* msg);
  static const ::Protocol::SRotator& rotation(const SEnemy* msg);
};

const ::Protocol::SVector&
SEnemy::_Internal::location(const SEnemy* msg) {
  return *msg->_impl_.location_;
}
const ::Protocol::SRotator&
SEnemy::_Internal::rotation(const SEnemy* msg) {
  return *msg->_impl_.rotation_;
}
SEnemy::SEnemy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.SEnemy)
}
SEnemy::SEnemy(const SEnemy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SEnemy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.location_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.state_){}
    , decltype(_impl_.hp_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_location()) {
    _this->_impl_.location_ = new ::Protocol::SVector(*from._impl_.location_);
  }
  if (from._internal_has_rotation()) {
    _this->_impl_.rotation_ = new ::Protocol::SRotator(*from._impl_.rotation_);
  }
  ::memcpy(&_impl_.state_, &from._impl_.state_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hp_) -
    reinterpret_cast<char*>(&_impl_.state_)) + sizeof(_impl_.hp_));
  // @@protoc_insertion_point(copy_constructor:Protocol.SEnemy)
}

inline void SEnemy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.location_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.state_){0}
    , decltype(_impl_.hp_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SEnemy::~SEnemy() {
  // @@protoc_insertion_point(destructor:Protocol.SEnemy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SEnemy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.location_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
}

void SEnemy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SEnemy::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.SEnemy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.location_ != nullptr) {
    delete _impl_.location_;
  }
  _impl_.location_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
  ::memset(&_impl_.state_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.hp_) -
      reinterpret_cast<char*>(&_impl_.state_)) + sizeof(_impl_.hp_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SEnemy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.EEnemyState state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_state(static_cast<::Protocol::EEnemyState>(val));
        } else
          goto handle_unusual;
        continue;
      // float hp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.hp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.SVector location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_location(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.SRotator rotation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SEnemy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.SEnemy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.EEnemyState state = 1;
  if (this->_internal_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  // float hp = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_hp = this->_internal_hp();
  uint32_t raw_hp;
  memcpy(&raw_hp, &tmp_hp, sizeof(tmp_hp));
  if (raw_hp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_hp(), target);
  }

  // .Protocol.SVector location = 3;
  if (this->_internal_has_location()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::location(this),
        _Internal::location(this).GetCachedSize(), target, stream);
  }

  // .Protocol.SRotator rotation = 4;
  if (this->_internal_has_rotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.SEnemy)
  return target;
}

size_t SEnemy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.SEnemy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.SVector location = 3;
  if (this->_internal_has_location()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.location_);
  }

  // .Protocol.SRotator rotation = 4;
  if (this->_internal_has_rotation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rotation_);
  }

  // .Protocol.EEnemyState state = 1;
  if (this->_internal_state() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
  }

  // float hp = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_hp = this->_internal_hp();
  uint32_t raw_hp;
  memcpy(&raw_hp, &tmp_hp, sizeof(tmp_hp));
  if (raw_hp != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SEnemy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SEnemy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SEnemy::GetClassData() const { return &_class_data_; }


void SEnemy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SEnemy*>(&to_msg);
  auto& from = static_cast<const SEnemy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.SEnemy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_location()) {
    _this->_internal_mutable_location()->::Protocol::SVector::MergeFrom(
        from._internal_location());
  }
  if (from._internal_has_rotation()) {
    _this->_internal_mutable_rotation()->::Protocol::SRotator::MergeFrom(
        from._internal_rotation());
  }
  if (from._internal_state() != 0) {
    _this->_internal_set_state(from._internal_state());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_hp = from._internal_hp();
  uint32_t raw_hp;
  memcpy(&raw_hp, &tmp_hp, sizeof(tmp_hp));
  if (raw_hp != 0) {
    _this->_internal_set_hp(from._internal_hp());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SEnemy::CopyFrom(const SEnemy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.SEnemy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SEnemy::IsInitialized() const {
  return true;
}

void SEnemy::InternalSwap(SEnemy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SEnemy, _impl_.hp_)
      + sizeof(SEnemy::_impl_.hp_)
      - PROTOBUF_FIELD_OFFSET(SEnemy, _impl_.location_)>(
          reinterpret_cast<char*>(&_impl_.location_),
          reinterpret_cast<char*>(&other->_impl_.location_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SEnemy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_PacketStruct_2eproto_getter, &descriptor_table_PacketStruct_2eproto_once,
      file_level_metadata_PacketStruct_2eproto[10]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Protocol::SServerInfo*
Arena::CreateMaybeMessage< ::Protocol::SServerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::SServerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::SCharacterAppearance*
Arena::CreateMaybeMessage< ::Protocol::SCharacterAppearance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::SCharacterAppearance >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::SCharacterEqipment*
Arena::CreateMaybeMessage< ::Protocol::SCharacterEqipment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::SCharacterEqipment >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::SCharacterData*
Arena::CreateMaybeMessage< ::Protocol::SCharacterData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::SCharacterData >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::SVector*
Arena::CreateMaybeMessage< ::Protocol::SVector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::SVector >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::SVector2D*
Arena::CreateMaybeMessage< ::Protocol::SVector2D >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::SVector2D >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::SVelocity*
Arena::CreateMaybeMessage< ::Protocol::SVelocity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::SVelocity >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::SRotator*
Arena::CreateMaybeMessage< ::Protocol::SRotator >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::SRotator >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::STransform*
Arena::CreateMaybeMessage< ::Protocol::STransform >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::STransform >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::SItem*
Arena::CreateMaybeMessage< ::Protocol::SItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::SItem >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::SEnemy*
Arena::CreateMaybeMessage< ::Protocol::SEnemy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::SEnemy >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

#if defined(_MSC_VER)
		 #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
#endif

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PacketStruct.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_PacketStruct_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_PacketStruct_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "PacketEnum.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_PacketStruct_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_PacketStruct_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_PacketStruct_2eproto;
namespace Protocol {
class SCharacterAppearance;
struct SCharacterAppearanceDefaultTypeInternal;
extern SCharacterAppearanceDefaultTypeInternal _SCharacterAppearance_default_instance_;
class SCharacterData;
struct SCharacterDataDefaultTypeInternal;
extern SCharacterDataDefaultTypeInternal _SCharacterData_default_instance_;
class SCharacterEqipment;
struct SCharacterEqipmentDefaultTypeInternal;
extern SCharacterEqipmentDefaultTypeInternal _SCharacterEqipment_default_instance_;
class SFriend;
struct SFriendDefaultTypeInternal;
extern SFriendDefaultTypeInternal _SFriend_default_instance_;
class SItem;
struct SItemDefaultTypeInternal;
extern SItemDefaultTypeInternal _SItem_default_instance_;
class SRotator;
struct SRotatorDefaultTypeInternal;
extern SRotatorDefaultTypeInternal _SRotator_default_instance_;
class SServerInfo;
struct SServerInfoDefaultTypeInternal;
extern SServerInfoDefaultTypeInternal _SServerInfo_default_instance_;
class SStat;
struct SStatDefaultTypeInternal;
extern SStatDefaultTypeInternal _SStat_default_instance_;
class STransform;
struct STransformDefaultTypeInternal;
extern STransformDefaultTypeInternal _STransform_default_instance_;
class SVector;
struct SVectorDefaultTypeInternal;
extern SVectorDefaultTypeInternal _SVector_default_instance_;
class SVector2D;
struct SVector2DDefaultTypeInternal;
extern SVector2DDefaultTypeInternal _SVector2D_default_instance_;
class SVelocity;
struct SVelocityDefaultTypeInternal;
extern SVelocityDefaultTypeInternal _SVelocity_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::SCharacterAppearance* Arena::CreateMaybeMessage<::Protocol::SCharacterAppearance>(Arena*);
template<> ::Protocol::SCharacterData* Arena::CreateMaybeMessage<::Protocol::SCharacterData>(Arena*);
template<> ::Protocol::SCharacterEqipment* Arena::CreateMaybeMessage<::Protocol::SCharacterEqipment>(Arena*);
template<> ::Protocol::SFriend* Arena::CreateMaybeMessage<::Protocol::SFriend>(Arena*);
template<> ::Protocol::SItem* Arena::CreateMaybeMessage<::Protocol::SItem>(Arena*);
template<> ::Protocol::SRotator* Arena::CreateMaybeMessage<::Protocol::SRotator>(Arena*);
template<> ::Protocol::SServerInfo* Arena::CreateMaybeMessage<::Protocol::SServerInfo>(Arena*);
template<> ::Protocol::SStat* Arena::CreateMaybeMessage<::Protocol::SStat>(Arena*);
template<> ::Protocol::STransform* Arena::CreateMaybeMessage<::Protocol::STransform>(Arena*);
template<> ::Protocol::SVector* Arena::CreateMaybeMessage<::Protocol::SVector>(Arena*);
template<> ::Protocol::SVector2D* Arena::CreateMaybeMessage<::Protocol::SVector2D>(Arena*);
template<> ::Protocol::SVelocity* Arena::CreateMaybeMessage<::Protocol::SVelocity>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class SServerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SServerInfo) */ {
 public:
  inline SServerInfo() : SServerInfo(nullptr) {}
  ~SServerInfo() override;
  explicit PROTOBUF_CONSTEXPR SServerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SServerInfo(const SServerInfo& from);
  SServerInfo(SServerInfo&& from) noexcept
    : SServerInfo() {
    *this = ::std::move(from);
  }

  inline SServerInfo& operator=(const SServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SServerInfo& operator=(SServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SServerInfo* internal_default_instance() {
    return reinterpret_cast<const SServerInfo*>(
               &_SServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SServerInfo& a, SServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SServerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SServerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SServerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SServerInfo& from) {
    SServerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SServerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SServerInfo";
  }
  protected:
  explicit SServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 2,
    kNameFieldNumber = 4,
    kIdFieldNumber = 1,
    kPortFieldNumber = 3,
  };
  // bytes ip = 2;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // bytes name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 port = 3;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t id_;
    int32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PacketStruct_2eproto;
};
// -------------------------------------------------------------------

class SCharacterAppearance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SCharacterAppearance) */ {
 public:
  inline SCharacterAppearance() : SCharacterAppearance(nullptr) {}
  ~SCharacterAppearance() override;
  explicit PROTOBUF_CONSTEXPR SCharacterAppearance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCharacterAppearance(const SCharacterAppearance& from);
  SCharacterAppearance(SCharacterAppearance&& from) noexcept
    : SCharacterAppearance() {
    *this = ::std::move(from);
  }

  inline SCharacterAppearance& operator=(const SCharacterAppearance& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCharacterAppearance& operator=(SCharacterAppearance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCharacterAppearance& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCharacterAppearance* internal_default_instance() {
    return reinterpret_cast<const SCharacterAppearance*>(
               &_SCharacterAppearance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SCharacterAppearance& a, SCharacterAppearance& b) {
    a.Swap(&b);
  }
  inline void Swap(SCharacterAppearance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCharacterAppearance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCharacterAppearance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCharacterAppearance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCharacterAppearance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCharacterAppearance& from) {
    SCharacterAppearance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCharacterAppearance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SCharacterAppearance";
  }
  protected:
  explicit SCharacterAppearance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRaceFieldNumber = 1,
    kSeatFieldNumber = 2,
    kSkinColorFieldNumber = 3,
    kHairColorFieldNumber = 4,
    kEyeColorFieldNumber = 5,
    kEyebrowColorFieldNumber = 6,
  };
  // .Protocol.ERace race = 1;
  void clear_race();
  ::Protocol::ERace race() const;
  void set_race(::Protocol::ERace value);
  private:
  ::Protocol::ERace _internal_race() const;
  void _internal_set_race(::Protocol::ERace value);
  public:

  // int32 seat = 2;
  void clear_seat();
  int32_t seat() const;
  void set_seat(int32_t value);
  private:
  int32_t _internal_seat() const;
  void _internal_set_seat(int32_t value);
  public:

  // int32 skin_color = 3;
  void clear_skin_color();
  int32_t skin_color() const;
  void set_skin_color(int32_t value);
  private:
  int32_t _internal_skin_color() const;
  void _internal_set_skin_color(int32_t value);
  public:

  // int32 hair_color = 4;
  void clear_hair_color();
  int32_t hair_color() const;
  void set_hair_color(int32_t value);
  private:
  int32_t _internal_hair_color() const;
  void _internal_set_hair_color(int32_t value);
  public:

  // int32 eye_color = 5;
  void clear_eye_color();
  int32_t eye_color() const;
  void set_eye_color(int32_t value);
  private:
  int32_t _internal_eye_color() const;
  void _internal_set_eye_color(int32_t value);
  public:

  // int32 eyebrow_color = 6;
  void clear_eyebrow_color();
  int32_t eyebrow_color() const;
  void set_eyebrow_color(int32_t value);
  private:
  int32_t _internal_eyebrow_color() const;
  void _internal_set_eyebrow_color(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SCharacterAppearance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int race_;
    int32_t seat_;
    int32_t skin_color_;
    int32_t hair_color_;
    int32_t eye_color_;
    int32_t eyebrow_color_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PacketStruct_2eproto;
};
// -------------------------------------------------------------------

class SCharacterEqipment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SCharacterEqipment) */ {
 public:
  inline SCharacterEqipment() : SCharacterEqipment(nullptr) {}
  ~SCharacterEqipment() override;
  explicit PROTOBUF_CONSTEXPR SCharacterEqipment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCharacterEqipment(const SCharacterEqipment& from);
  SCharacterEqipment(SCharacterEqipment&& from) noexcept
    : SCharacterEqipment() {
    *this = ::std::move(from);
  }

  inline SCharacterEqipment& operator=(const SCharacterEqipment& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCharacterEqipment& operator=(SCharacterEqipment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCharacterEqipment& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCharacterEqipment* internal_default_instance() {
    return reinterpret_cast<const SCharacterEqipment*>(
               &_SCharacterEqipment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SCharacterEqipment& a, SCharacterEqipment& b) {
    a.Swap(&b);
  }
  inline void Swap(SCharacterEqipment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCharacterEqipment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCharacterEqipment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCharacterEqipment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCharacterEqipment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCharacterEqipment& from) {
    SCharacterEqipment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCharacterEqipment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SCharacterEqipment";
  }
  protected:
  explicit SCharacterEqipment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHairFieldNumber = 1,
    kHelmetFieldNumber = 2,
    kShouldersFieldNumber = 3,
    kChestFieldNumber = 4,
    kBracersFieldNumber = 5,
    kHandsFieldNumber = 6,
    kPantsFieldNumber = 7,
    kBootsFieldNumber = 8,
    kWeaponLFieldNumber = 9,
    kWeaponRFieldNumber = 10,
  };
  // int32 hair = 1;
  void clear_hair();
  int32_t hair() const;
  void set_hair(int32_t value);
  private:
  int32_t _internal_hair() const;
  void _internal_set_hair(int32_t value);
  public:

  // int32 helmet = 2;
  void clear_helmet();
  int32_t helmet() const;
  void set_helmet(int32_t value);
  private:
  int32_t _internal_helmet() const;
  void _internal_set_helmet(int32_t value);
  public:

  // int32 shoulders = 3;
  void clear_shoulders();
  int32_t shoulders() const;
  void set_shoulders(int32_t value);
  private:
  int32_t _internal_shoulders() const;
  void _internal_set_shoulders(int32_t value);
  public:

  // int32 chest = 4;
  void clear_chest();
  int32_t chest() const;
  void set_chest(int32_t value);
  private:
  int32_t _internal_chest() const;
  void _internal_set_chest(int32_t value);
  public:

  // int32 bracers = 5;
  void clear_bracers();
  int32_t bracers() const;
  void set_bracers(int32_t value);
  private:
  int32_t _internal_bracers() const;
  void _internal_set_bracers(int32_t value);
  public:

  // int32 hands = 6;
  void clear_hands();
  int32_t hands() const;
  void set_hands(int32_t value);
  private:
  int32_t _internal_hands() const;
  void _internal_set_hands(int32_t value);
  public:

  // int32 pants = 7;
  void clear_pants();
  int32_t pants() const;
  void set_pants(int32_t value);
  private:
  int32_t _internal_pants() const;
  void _internal_set_pants(int32_t value);
  public:

  // int32 boots = 8;
  void clear_boots();
  int32_t boots() const;
  void set_boots(int32_t value);
  private:
  int32_t _internal_boots() const;
  void _internal_set_boots(int32_t value);
  public:

  // int32 weapon_l = 9;
  void clear_weapon_l();
  int32_t weapon_l() const;
  void set_weapon_l(int32_t value);
  private:
  int32_t _internal_weapon_l() const;
  void _internal_set_weapon_l(int32_t value);
  public:

  // int32 weapon_r = 10;
  void clear_weapon_r();
  int32_t weapon_r() const;
  void set_weapon_r(int32_t value);
  private:
  int32_t _internal_weapon_r() const;
  void _internal_set_weapon_r(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SCharacterEqipment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t hair_;
    int32_t helmet_;
    int32_t shoulders_;
    int32_t chest_;
    int32_t bracers_;
    int32_t hands_;
    int32_t pants_;
    int32_t boots_;
    int32_t weapon_l_;
    int32_t weapon_r_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PacketStruct_2eproto;
};
// -------------------------------------------------------------------

class SCharacterData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SCharacterData) */ {
 public:
  inline SCharacterData() : SCharacterData(nullptr) {}
  ~SCharacterData() override;
  explicit PROTOBUF_CONSTEXPR SCharacterData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCharacterData(const SCharacterData& from);
  SCharacterData(SCharacterData&& from) noexcept
    : SCharacterData() {
    *this = ::std::move(from);
  }

  inline SCharacterData& operator=(const SCharacterData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCharacterData& operator=(SCharacterData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SCharacterData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCharacterData* internal_default_instance() {
    return reinterpret_cast<const SCharacterData*>(
               &_SCharacterData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SCharacterData& a, SCharacterData& b) {
    a.Swap(&b);
  }
  inline void Swap(SCharacterData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCharacterData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCharacterData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCharacterData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SCharacterData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SCharacterData& from) {
    SCharacterData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCharacterData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SCharacterData";
  }
  protected:
  explicit SCharacterData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAppearanceFieldNumber = 5,
    kEqipmentFieldNumber = 6,
    kLevelFieldNumber = 2,
    kExperienceFieldNumber = 3,
    kCharacterClassFieldNumber = 4,
  };
  // bytes name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Protocol.SCharacterAppearance appearance = 5;
  bool has_appearance() const;
  private:
  bool _internal_has_appearance() const;
  public:
  void clear_appearance();
  const ::Protocol::SCharacterAppearance& appearance() const;
  PROTOBUF_NODISCARD ::Protocol::SCharacterAppearance* release_appearance();
  ::Protocol::SCharacterAppearance* mutable_appearance();
  void set_allocated_appearance(::Protocol::SCharacterAppearance* appearance);
  private:
  const ::Protocol::SCharacterAppearance& _internal_appearance() const;
  ::Protocol::SCharacterAppearance* _internal_mutable_appearance();
  public:
  void unsafe_arena_set_allocated_appearance(
      ::Protocol::SCharacterAppearance* appearance);
  ::Protocol::SCharacterAppearance* unsafe_arena_release_appearance();

  // .Protocol.SCharacterEqipment eqipment = 6;
  bool has_eqipment() const;
  private:
  bool _internal_has_eqipment() const;
  public:
  void clear_eqipment();
  const ::Protocol::SCharacterEqipment& eqipment() const;
  PROTOBUF_NODISCARD ::Protocol::SCharacterEqipment* release_eqipment();
  ::Protocol::SCharacterEqipment* mutable_eqipment();
  void set_allocated_eqipment(::Protocol::SCharacterEqipment* eqipment);
  private:
  const ::Protocol::SCharacterEqipment& _internal_eqipment() const;
  ::Protocol::SCharacterEqipment* _internal_mutable_eqipment();
  public:
  void unsafe_arena_set_allocated_eqipment(
      ::Protocol::SCharacterEqipment* eqipment);
  ::Protocol::SCharacterEqipment* unsafe_arena_release_eqipment();

  // int32 level = 2;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // int32 experience = 3;
  void clear_experience();
  int32_t experience() const;
  void set_experience(int32_t value);
  private:
  int32_t _internal_experience() const;
  void _internal_set_experience(int32_t value);
  public:

  // .Protocol.ECharacterClass character_class = 4;
  void clear_character_class();
  ::Protocol::ECharacterClass character_class() const;
  void set_character_class(::Protocol::ECharacterClass value);
  private:
  ::Protocol::ECharacterClass _internal_character_class() const;
  void _internal_set_character_class(::Protocol::ECharacterClass value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SCharacterData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::Protocol::SCharacterAppearance* appearance_;
    ::Protocol::SCharacterEqipment* eqipment_;
    int32_t level_;
    int32_t experience_;
    int character_class_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PacketStruct_2eproto;
};
// -------------------------------------------------------------------

class SVector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SVector) */ {
 public:
  inline SVector() : SVector(nullptr) {}
  ~SVector() override;
  explicit PROTOBUF_CONSTEXPR SVector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SVector(const SVector& from);
  SVector(SVector&& from) noexcept
    : SVector() {
    *this = ::std::move(from);
  }

  inline SVector& operator=(const SVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline SVector& operator=(SVector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SVector& default_instance() {
    return *internal_default_instance();
  }
  static inline const SVector* internal_default_instance() {
    return reinterpret_cast<const SVector*>(
               &_SVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SVector& a, SVector& b) {
    a.Swap(&b);
  }
  inline void Swap(SVector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SVector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SVector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SVector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SVector& from) {
    SVector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SVector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SVector";
  }
  protected:
  explicit SVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SVector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PacketStruct_2eproto;
};
// -------------------------------------------------------------------

class SVector2D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SVector2D) */ {
 public:
  inline SVector2D() : SVector2D(nullptr) {}
  ~SVector2D() override;
  explicit PROTOBUF_CONSTEXPR SVector2D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SVector2D(const SVector2D& from);
  SVector2D(SVector2D&& from) noexcept
    : SVector2D() {
    *this = ::std::move(from);
  }

  inline SVector2D& operator=(const SVector2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline SVector2D& operator=(SVector2D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SVector2D& default_instance() {
    return *internal_default_instance();
  }
  static inline const SVector2D* internal_default_instance() {
    return reinterpret_cast<const SVector2D*>(
               &_SVector2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SVector2D& a, SVector2D& b) {
    a.Swap(&b);
  }
  inline void Swap(SVector2D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SVector2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SVector2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SVector2D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SVector2D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SVector2D& from) {
    SVector2D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SVector2D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SVector2D";
  }
  protected:
  explicit SVector2D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SVector2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PacketStruct_2eproto;
};
// -------------------------------------------------------------------

class SVelocity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SVelocity) */ {
 public:
  inline SVelocity() : SVelocity(nullptr) {}
  ~SVelocity() override;
  explicit PROTOBUF_CONSTEXPR SVelocity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SVelocity(const SVelocity& from);
  SVelocity(SVelocity&& from) noexcept
    : SVelocity() {
    *this = ::std::move(from);
  }

  inline SVelocity& operator=(const SVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline SVelocity& operator=(SVelocity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SVelocity& default_instance() {
    return *internal_default_instance();
  }
  static inline const SVelocity* internal_default_instance() {
    return reinterpret_cast<const SVelocity*>(
               &_SVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SVelocity& a, SVelocity& b) {
    a.Swap(&b);
  }
  inline void Swap(SVelocity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SVelocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SVelocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SVelocity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SVelocity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SVelocity& from) {
    SVelocity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SVelocity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SVelocity";
  }
  protected:
  explicit SVelocity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SVelocity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PacketStruct_2eproto;
};
// -------------------------------------------------------------------

class SRotator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SRotator) */ {
 public:
  inline SRotator() : SRotator(nullptr) {}
  ~SRotator() override;
  explicit PROTOBUF_CONSTEXPR SRotator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SRotator(const SRotator& from);
  SRotator(SRotator&& from) noexcept
    : SRotator() {
    *this = ::std::move(from);
  }

  inline SRotator& operator=(const SRotator& from) {
    CopyFrom(from);
    return *this;
  }
  inline SRotator& operator=(SRotator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SRotator& default_instance() {
    return *internal_default_instance();
  }
  static inline const SRotator* internal_default_instance() {
    return reinterpret_cast<const SRotator*>(
               &_SRotator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SRotator& a, SRotator& b) {
    a.Swap(&b);
  }
  inline void Swap(SRotator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SRotator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SRotator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SRotator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SRotator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SRotator& from) {
    SRotator::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SRotator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SRotator";
  }
  protected:
  explicit SRotator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRollFieldNumber = 1,
    kPitchFieldNumber = 2,
    kYawFieldNumber = 3,
  };
  // float roll = 1;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // float pitch = 2;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float yaw = 3;
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SRotator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float roll_;
    float pitch_;
    float yaw_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PacketStruct_2eproto;
};
// -------------------------------------------------------------------

class STransform final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.STransform) */ {
 public:
  inline STransform() : STransform(nullptr) {}
  ~STransform() override;
  explicit PROTOBUF_CONSTEXPR STransform(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STransform(const STransform& from);
  STransform(STransform&& from) noexcept
    : STransform() {
    *this = ::std::move(from);
  }

  inline STransform& operator=(const STransform& from) {
    CopyFrom(from);
    return *this;
  }
  inline STransform& operator=(STransform&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STransform& default_instance() {
    return *internal_default_instance();
  }
  static inline const STransform* internal_default_instance() {
    return reinterpret_cast<const STransform*>(
               &_STransform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(STransform& a, STransform& b) {
    a.Swap(&b);
  }
  inline void Swap(STransform* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STransform* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STransform* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<STransform>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const STransform& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const STransform& from) {
    STransform::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STransform* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.STransform";
  }
  protected:
  explicit STransform(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kRotationFieldNumber = 2,
    kScaleFieldNumber = 3,
  };
  // .Protocol.SVector location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::Protocol::SVector& location() const;
  PROTOBUF_NODISCARD ::Protocol::SVector* release_location();
  ::Protocol::SVector* mutable_location();
  void set_allocated_location(::Protocol::SVector* location);
  private:
  const ::Protocol::SVector& _internal_location() const;
  ::Protocol::SVector* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::Protocol::SVector* location);
  ::Protocol::SVector* unsafe_arena_release_location();

  // .Protocol.SRotator rotation = 2;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::Protocol::SRotator& rotation() const;
  PROTOBUF_NODISCARD ::Protocol::SRotator* release_rotation();
  ::Protocol::SRotator* mutable_rotation();
  void set_allocated_rotation(::Protocol::SRotator* rotation);
  private:
  const ::Protocol::SRotator& _internal_rotation() const;
  ::Protocol::SRotator* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::Protocol::SRotator* rotation);
  ::Protocol::SRotator* unsafe_arena_release_rotation();

  // .Protocol.SVector scale = 3;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  const ::Protocol::SVector& scale() const;
  PROTOBUF_NODISCARD ::Protocol::SVector* release_scale();
  ::Protocol::SVector* mutable_scale();
  void set_allocated_scale(::Protocol::SVector* scale);
  private:
  const ::Protocol::SVector& _internal_scale() const;
  ::Protocol::SVector* _internal_mutable_scale();
  public:
  void unsafe_arena_set_allocated_scale(
      ::Protocol::SVector* scale);
  ::Protocol::SVector* unsafe_arena_release_scale();

  // @@protoc_insertion_point(class_scope:Protocol.STransform)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::SVector* location_;
    ::Protocol::SRotator* rotation_;
    ::Protocol::SVector* scale_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PacketStruct_2eproto;
};
// -------------------------------------------------------------------

class SItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SItem) */ {
 public:
  inline SItem() : SItem(nullptr) {}
  ~SItem() override;
  explicit PROTOBUF_CONSTEXPR SItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SItem(const SItem& from);
  SItem(SItem&& from) noexcept
    : SItem() {
    *this = ::std::move(from);
  }

  inline SItem& operator=(const SItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline SItem& operator=(SItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const SItem* internal_default_instance() {
    return reinterpret_cast<const SItem*>(
               &_SItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SItem& a, SItem& b) {
    a.Swap(&b);
  }
  inline void Swap(SItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SItem& from) {
    SItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SItem";
  }
  protected:
  explicit SItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldPositionFieldNumber = 3,
    kInvenPositionFieldNumber = 4,
    kObjectIdFieldNumber = 1,
    kItemCodeFieldNumber = 2,
    kRotationFieldNumber = 5,
    kAmountFieldNumber = 6,
  };
  // .Protocol.SVector world_position = 3;
  bool has_world_position() const;
  private:
  bool _internal_has_world_position() const;
  public:
  void clear_world_position();
  const ::Protocol::SVector& world_position() const;
  PROTOBUF_NODISCARD ::Protocol::SVector* release_world_position();
  ::Protocol::SVector* mutable_world_position();
  void set_allocated_world_position(::Protocol::SVector* world_position);
  private:
  const ::Protocol::SVector& _internal_world_position() const;
  ::Protocol::SVector* _internal_mutable_world_position();
  public:
  void unsafe_arena_set_allocated_world_position(
      ::Protocol::SVector* world_position);
  ::Protocol::SVector* unsafe_arena_release_world_position();

  // .Protocol.SVector2D inven_position = 4;
  bool has_inven_position() const;
  private:
  bool _internal_has_inven_position() const;
  public:
  void clear_inven_position();
  const ::Protocol::SVector2D& inven_position() const;
  PROTOBUF_NODISCARD ::Protocol::SVector2D* release_inven_position();
  ::Protocol::SVector2D* mutable_inven_position();
  void set_allocated_inven_position(::Protocol::SVector2D* inven_position);
  private:
  const ::Protocol::SVector2D& _internal_inven_position() const;
  ::Protocol::SVector2D* _internal_mutable_inven_position();
  public:
  void unsafe_arena_set_allocated_inven_position(
      ::Protocol::SVector2D* inven_position);
  ::Protocol::SVector2D* unsafe_arena_release_inven_position();

  // int64 object_id = 1;
  void clear_object_id();
  int64_t object_id() const;
  void set_object_id(int64_t value);
  private:
  int64_t _internal_object_id() const;
  void _internal_set_object_id(int64_t value);
  public:

  // int32 item_code = 2;
  void clear_item_code();
  int32_t item_code() const;
  void set_item_code(int32_t value);
  private:
  int32_t _internal_item_code() const;
  void _internal_set_item_code(int32_t value);
  public:

  // int32 rotation = 5;
  void clear_rotation();
  int32_t rotation() const;
  void set_rotation(int32_t value);
  private:
  int32_t _internal_rotation() const;
  void _internal_set_rotation(int32_t value);
  public:

  // int32 amount = 6;
  void clear_amount();
  int32_t amount() const;
  void set_amount(int32_t value);
  private:
  int32_t _internal_amount() const;
  void _internal_set_amount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::SVector* world_position_;
    ::Protocol::SVector2D* inven_position_;
    int64_t object_id_;
    int32_t item_code_;
    int32_t rotation_;
    int32_t amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PacketStruct_2eproto;
};
// -------------------------------------------------------------------

class SStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SStat) */ {
 public:
  inline SStat() : SStat(nullptr) {}
  ~SStat() override;
  explicit PROTOBUF_CONSTEXPR SStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SStat(const SStat& from);
  SStat(SStat&& from) noexcept
    : SStat() {
    *this = ::std::move(from);
  }

  inline SStat& operator=(const SStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline SStat& operator=(SStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const SStat* internal_default_instance() {
    return reinterpret_cast<const SStat*>(
               &_SStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SStat& a, SStat& b) {
    a.Swap(&b);
  }
  inline void Swap(SStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SStat& from) {
    SStat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SStat";
  }
  protected:
  explicit SStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatTypeFieldNumber = 1,
    kStatValueFieldNumber = 2,
  };
  // .Protocol.EStatType stat_type = 1;
  void clear_stat_type();
  ::Protocol::EStatType stat_type() const;
  void set_stat_type(::Protocol::EStatType value);
  private:
  ::Protocol::EStatType _internal_stat_type() const;
  void _internal_set_stat_type(::Protocol::EStatType value);
  public:

  // float stat_value = 2;
  void clear_stat_value();
  float stat_value() const;
  void set_stat_value(float value);
  private:
  float _internal_stat_value() const;
  void _internal_set_stat_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int stat_type_;
    float stat_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PacketStruct_2eproto;
};
// -------------------------------------------------------------------

class SFriend final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.SFriend) */ {
 public:
  inline SFriend() : SFriend(nullptr) {}
  ~SFriend() override;
  explicit PROTOBUF_CONSTEXPR SFriend(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SFriend(const SFriend& from);
  SFriend(SFriend&& from) noexcept
    : SFriend() {
    *this = ::std::move(from);
  }

  inline SFriend& operator=(const SFriend& from) {
    CopyFrom(from);
    return *this;
  }
  inline SFriend& operator=(SFriend&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SFriend& default_instance() {
    return *internal_default_instance();
  }
  static inline const SFriend* internal_default_instance() {
    return reinterpret_cast<const SFriend*>(
               &_SFriend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SFriend& a, SFriend& b) {
    a.Swap(&b);
  }
  inline void Swap(SFriend* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SFriend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SFriend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SFriend>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SFriend& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SFriend& from) {
    SFriend::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SFriend* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.SFriend";
  }
  protected:
  explicit SFriend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNickNameFieldNumber = 1,
    kLevelFieldNumber = 2,
    kCharacterClassFieldNumber = 3,
    kLocaleFieldNumber = 4,
    kStateFieldNumber = 5,
  };
  // bytes nick_name = 1;
  void clear_nick_name();
  const std::string& nick_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nick_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nick_name();
  PROTOBUF_NODISCARD std::string* release_nick_name();
  void set_allocated_nick_name(std::string* nick_name);
  private:
  const std::string& _internal_nick_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nick_name(const std::string& value);
  std::string* _internal_mutable_nick_name();
  public:

  // int32 level = 2;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // .Protocol.ECharacterClass character_class = 3;
  void clear_character_class();
  ::Protocol::ECharacterClass character_class() const;
  void set_character_class(::Protocol::ECharacterClass value);
  private:
  ::Protocol::ECharacterClass _internal_character_class() const;
  void _internal_set_character_class(::Protocol::ECharacterClass value);
  public:

  // int32 locale = 4;
  void clear_locale();
  int32_t locale() const;
  void set_locale(int32_t value);
  private:
  int32_t _internal_locale() const;
  void _internal_set_locale(int32_t value);
  public:

  // int32 state = 5;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.SFriend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nick_name_;
    int32_t level_;
    int character_class_;
    int32_t locale_;
    int32_t state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PacketStruct_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SServerInfo

// int32 id = 1;
inline void SServerInfo::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t SServerInfo::_internal_id() const {
  return _impl_.id_;
}
inline int32_t SServerInfo::id() const {
  // @@protoc_insertion_point(field_get:Protocol.SServerInfo.id)
  return _internal_id();
}
inline void SServerInfo::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void SServerInfo::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.SServerInfo.id)
}

// bytes ip = 2;
inline void SServerInfo::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& SServerInfo::ip() const {
  // @@protoc_insertion_point(field_get:Protocol.SServerInfo.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SServerInfo::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.SServerInfo.ip)
}
inline std::string* SServerInfo::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:Protocol.SServerInfo.ip)
  return _s;
}
inline const std::string& SServerInfo::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void SServerInfo::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* SServerInfo::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* SServerInfo::release_ip() {
  // @@protoc_insertion_point(field_release:Protocol.SServerInfo.ip)
  return _impl_.ip_.Release();
}
inline void SServerInfo::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.SServerInfo.ip)
}

// int32 port = 3;
inline void SServerInfo::clear_port() {
  _impl_.port_ = 0;
}
inline int32_t SServerInfo::_internal_port() const {
  return _impl_.port_;
}
inline int32_t SServerInfo::port() const {
  // @@protoc_insertion_point(field_get:Protocol.SServerInfo.port)
  return _internal_port();
}
inline void SServerInfo::_internal_set_port(int32_t value) {
  
  _impl_.port_ = value;
}
inline void SServerInfo::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Protocol.SServerInfo.port)
}

// bytes name = 4;
inline void SServerInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SServerInfo::name() const {
  // @@protoc_insertion_point(field_get:Protocol.SServerInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SServerInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.SServerInfo.name)
}
inline std::string* SServerInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.SServerInfo.name)
  return _s;
}
inline const std::string& SServerInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SServerInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SServerInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SServerInfo::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.SServerInfo.name)
  return _impl_.name_.Release();
}
inline void SServerInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.SServerInfo.name)
}

// -------------------------------------------------------------------

// SCharacterAppearance

// .Protocol.ERace race = 1;
inline void SCharacterAppearance::clear_race() {
  _impl_.race_ = 0;
}
inline ::Protocol::ERace SCharacterAppearance::_internal_race() const {
  return static_cast< ::Protocol::ERace >(_impl_.race_);
}
inline ::Protocol::ERace SCharacterAppearance::race() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterAppearance.race)
  return _internal_race();
}
inline void SCharacterAppearance::_internal_set_race(::Protocol::ERace value) {
  
  _impl_.race_ = value;
}
inline void SCharacterAppearance::set_race(::Protocol::ERace value) {
  _internal_set_race(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterAppearance.race)
}

// int32 seat = 2;
inline void SCharacterAppearance::clear_seat() {
  _impl_.seat_ = 0;
}
inline int32_t SCharacterAppearance::_internal_seat() const {
  return _impl_.seat_;
}
inline int32_t SCharacterAppearance::seat() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterAppearance.seat)
  return _internal_seat();
}
inline void SCharacterAppearance::_internal_set_seat(int32_t value) {
  
  _impl_.seat_ = value;
}
inline void SCharacterAppearance::set_seat(int32_t value) {
  _internal_set_seat(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterAppearance.seat)
}

// int32 skin_color = 3;
inline void SCharacterAppearance::clear_skin_color() {
  _impl_.skin_color_ = 0;
}
inline int32_t SCharacterAppearance::_internal_skin_color() const {
  return _impl_.skin_color_;
}
inline int32_t SCharacterAppearance::skin_color() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterAppearance.skin_color)
  return _internal_skin_color();
}
inline void SCharacterAppearance::_internal_set_skin_color(int32_t value) {
  
  _impl_.skin_color_ = value;
}
inline void SCharacterAppearance::set_skin_color(int32_t value) {
  _internal_set_skin_color(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterAppearance.skin_color)
}

// int32 hair_color = 4;
inline void SCharacterAppearance::clear_hair_color() {
  _impl_.hair_color_ = 0;
}
inline int32_t SCharacterAppearance::_internal_hair_color() const {
  return _impl_.hair_color_;
}
inline int32_t SCharacterAppearance::hair_color() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterAppearance.hair_color)
  return _internal_hair_color();
}
inline void SCharacterAppearance::_internal_set_hair_color(int32_t value) {
  
  _impl_.hair_color_ = value;
}
inline void SCharacterAppearance::set_hair_color(int32_t value) {
  _internal_set_hair_color(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterAppearance.hair_color)
}

// int32 eye_color = 5;
inline void SCharacterAppearance::clear_eye_color() {
  _impl_.eye_color_ = 0;
}
inline int32_t SCharacterAppearance::_internal_eye_color() const {
  return _impl_.eye_color_;
}
inline int32_t SCharacterAppearance::eye_color() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterAppearance.eye_color)
  return _internal_eye_color();
}
inline void SCharacterAppearance::_internal_set_eye_color(int32_t value) {
  
  _impl_.eye_color_ = value;
}
inline void SCharacterAppearance::set_eye_color(int32_t value) {
  _internal_set_eye_color(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterAppearance.eye_color)
}

// int32 eyebrow_color = 6;
inline void SCharacterAppearance::clear_eyebrow_color() {
  _impl_.eyebrow_color_ = 0;
}
inline int32_t SCharacterAppearance::_internal_eyebrow_color() const {
  return _impl_.eyebrow_color_;
}
inline int32_t SCharacterAppearance::eyebrow_color() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterAppearance.eyebrow_color)
  return _internal_eyebrow_color();
}
inline void SCharacterAppearance::_internal_set_eyebrow_color(int32_t value) {
  
  _impl_.eyebrow_color_ = value;
}
inline void SCharacterAppearance::set_eyebrow_color(int32_t value) {
  _internal_set_eyebrow_color(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterAppearance.eyebrow_color)
}

// -------------------------------------------------------------------

// SCharacterEqipment

// int32 hair = 1;
inline void SCharacterEqipment::clear_hair() {
  _impl_.hair_ = 0;
}
inline int32_t SCharacterEqipment::_internal_hair() const {
  return _impl_.hair_;
}
inline int32_t SCharacterEqipment::hair() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterEqipment.hair)
  return _internal_hair();
}
inline void SCharacterEqipment::_internal_set_hair(int32_t value) {
  
  _impl_.hair_ = value;
}
inline void SCharacterEqipment::set_hair(int32_t value) {
  _internal_set_hair(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterEqipment.hair)
}

// int32 helmet = 2;
inline void SCharacterEqipment::clear_helmet() {
  _impl_.helmet_ = 0;
}
inline int32_t SCharacterEqipment::_internal_helmet() const {
  return _impl_.helmet_;
}
inline int32_t SCharacterEqipment::helmet() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterEqipment.helmet)
  return _internal_helmet();
}
inline void SCharacterEqipment::_internal_set_helmet(int32_t value) {
  
  _impl_.helmet_ = value;
}
inline void SCharacterEqipment::set_helmet(int32_t value) {
  _internal_set_helmet(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterEqipment.helmet)
}

// int32 shoulders = 3;
inline void SCharacterEqipment::clear_shoulders() {
  _impl_.shoulders_ = 0;
}
inline int32_t SCharacterEqipment::_internal_shoulders() const {
  return _impl_.shoulders_;
}
inline int32_t SCharacterEqipment::shoulders() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterEqipment.shoulders)
  return _internal_shoulders();
}
inline void SCharacterEqipment::_internal_set_shoulders(int32_t value) {
  
  _impl_.shoulders_ = value;
}
inline void SCharacterEqipment::set_shoulders(int32_t value) {
  _internal_set_shoulders(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterEqipment.shoulders)
}

// int32 chest = 4;
inline void SCharacterEqipment::clear_chest() {
  _impl_.chest_ = 0;
}
inline int32_t SCharacterEqipment::_internal_chest() const {
  return _impl_.chest_;
}
inline int32_t SCharacterEqipment::chest() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterEqipment.chest)
  return _internal_chest();
}
inline void SCharacterEqipment::_internal_set_chest(int32_t value) {
  
  _impl_.chest_ = value;
}
inline void SCharacterEqipment::set_chest(int32_t value) {
  _internal_set_chest(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterEqipment.chest)
}

// int32 bracers = 5;
inline void SCharacterEqipment::clear_bracers() {
  _impl_.bracers_ = 0;
}
inline int32_t SCharacterEqipment::_internal_bracers() const {
  return _impl_.bracers_;
}
inline int32_t SCharacterEqipment::bracers() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterEqipment.bracers)
  return _internal_bracers();
}
inline void SCharacterEqipment::_internal_set_bracers(int32_t value) {
  
  _impl_.bracers_ = value;
}
inline void SCharacterEqipment::set_bracers(int32_t value) {
  _internal_set_bracers(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterEqipment.bracers)
}

// int32 hands = 6;
inline void SCharacterEqipment::clear_hands() {
  _impl_.hands_ = 0;
}
inline int32_t SCharacterEqipment::_internal_hands() const {
  return _impl_.hands_;
}
inline int32_t SCharacterEqipment::hands() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterEqipment.hands)
  return _internal_hands();
}
inline void SCharacterEqipment::_internal_set_hands(int32_t value) {
  
  _impl_.hands_ = value;
}
inline void SCharacterEqipment::set_hands(int32_t value) {
  _internal_set_hands(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterEqipment.hands)
}

// int32 pants = 7;
inline void SCharacterEqipment::clear_pants() {
  _impl_.pants_ = 0;
}
inline int32_t SCharacterEqipment::_internal_pants() const {
  return _impl_.pants_;
}
inline int32_t SCharacterEqipment::pants() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterEqipment.pants)
  return _internal_pants();
}
inline void SCharacterEqipment::_internal_set_pants(int32_t value) {
  
  _impl_.pants_ = value;
}
inline void SCharacterEqipment::set_pants(int32_t value) {
  _internal_set_pants(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterEqipment.pants)
}

// int32 boots = 8;
inline void SCharacterEqipment::clear_boots() {
  _impl_.boots_ = 0;
}
inline int32_t SCharacterEqipment::_internal_boots() const {
  return _impl_.boots_;
}
inline int32_t SCharacterEqipment::boots() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterEqipment.boots)
  return _internal_boots();
}
inline void SCharacterEqipment::_internal_set_boots(int32_t value) {
  
  _impl_.boots_ = value;
}
inline void SCharacterEqipment::set_boots(int32_t value) {
  _internal_set_boots(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterEqipment.boots)
}

// int32 weapon_l = 9;
inline void SCharacterEqipment::clear_weapon_l() {
  _impl_.weapon_l_ = 0;
}
inline int32_t SCharacterEqipment::_internal_weapon_l() const {
  return _impl_.weapon_l_;
}
inline int32_t SCharacterEqipment::weapon_l() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterEqipment.weapon_l)
  return _internal_weapon_l();
}
inline void SCharacterEqipment::_internal_set_weapon_l(int32_t value) {
  
  _impl_.weapon_l_ = value;
}
inline void SCharacterEqipment::set_weapon_l(int32_t value) {
  _internal_set_weapon_l(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterEqipment.weapon_l)
}

// int32 weapon_r = 10;
inline void SCharacterEqipment::clear_weapon_r() {
  _impl_.weapon_r_ = 0;
}
inline int32_t SCharacterEqipment::_internal_weapon_r() const {
  return _impl_.weapon_r_;
}
inline int32_t SCharacterEqipment::weapon_r() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterEqipment.weapon_r)
  return _internal_weapon_r();
}
inline void SCharacterEqipment::_internal_set_weapon_r(int32_t value) {
  
  _impl_.weapon_r_ = value;
}
inline void SCharacterEqipment::set_weapon_r(int32_t value) {
  _internal_set_weapon_r(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterEqipment.weapon_r)
}

// -------------------------------------------------------------------

// SCharacterData

// bytes name = 1;
inline void SCharacterData::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SCharacterData::name() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SCharacterData::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.SCharacterData.name)
}
inline std::string* SCharacterData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.SCharacterData.name)
  return _s;
}
inline const std::string& SCharacterData::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SCharacterData::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SCharacterData::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SCharacterData::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.SCharacterData.name)
  return _impl_.name_.Release();
}
inline void SCharacterData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.SCharacterData.name)
}

// int32 level = 2;
inline void SCharacterData::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t SCharacterData::_internal_level() const {
  return _impl_.level_;
}
inline int32_t SCharacterData::level() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterData.level)
  return _internal_level();
}
inline void SCharacterData::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void SCharacterData::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterData.level)
}

// int32 experience = 3;
inline void SCharacterData::clear_experience() {
  _impl_.experience_ = 0;
}
inline int32_t SCharacterData::_internal_experience() const {
  return _impl_.experience_;
}
inline int32_t SCharacterData::experience() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterData.experience)
  return _internal_experience();
}
inline void SCharacterData::_internal_set_experience(int32_t value) {
  
  _impl_.experience_ = value;
}
inline void SCharacterData::set_experience(int32_t value) {
  _internal_set_experience(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterData.experience)
}

// .Protocol.ECharacterClass character_class = 4;
inline void SCharacterData::clear_character_class() {
  _impl_.character_class_ = 0;
}
inline ::Protocol::ECharacterClass SCharacterData::_internal_character_class() const {
  return static_cast< ::Protocol::ECharacterClass >(_impl_.character_class_);
}
inline ::Protocol::ECharacterClass SCharacterData::character_class() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterData.character_class)
  return _internal_character_class();
}
inline void SCharacterData::_internal_set_character_class(::Protocol::ECharacterClass value) {
  
  _impl_.character_class_ = value;
}
inline void SCharacterData::set_character_class(::Protocol::ECharacterClass value) {
  _internal_set_character_class(value);
  // @@protoc_insertion_point(field_set:Protocol.SCharacterData.character_class)
}

// .Protocol.SCharacterAppearance appearance = 5;
inline bool SCharacterData::_internal_has_appearance() const {
  return this != internal_default_instance() && _impl_.appearance_ != nullptr;
}
inline bool SCharacterData::has_appearance() const {
  return _internal_has_appearance();
}
inline void SCharacterData::clear_appearance() {
  if (GetArenaForAllocation() == nullptr && _impl_.appearance_ != nullptr) {
    delete _impl_.appearance_;
  }
  _impl_.appearance_ = nullptr;
}
inline const ::Protocol::SCharacterAppearance& SCharacterData::_internal_appearance() const {
  const ::Protocol::SCharacterAppearance* p = _impl_.appearance_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SCharacterAppearance&>(
      ::Protocol::_SCharacterAppearance_default_instance_);
}
inline const ::Protocol::SCharacterAppearance& SCharacterData::appearance() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterData.appearance)
  return _internal_appearance();
}
inline void SCharacterData::unsafe_arena_set_allocated_appearance(
    ::Protocol::SCharacterAppearance* appearance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.appearance_);
  }
  _impl_.appearance_ = appearance;
  if (appearance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.SCharacterData.appearance)
}
inline ::Protocol::SCharacterAppearance* SCharacterData::release_appearance() {
  
  ::Protocol::SCharacterAppearance* temp = _impl_.appearance_;
  _impl_.appearance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::SCharacterAppearance* SCharacterData::unsafe_arena_release_appearance() {
  // @@protoc_insertion_point(field_release:Protocol.SCharacterData.appearance)
  
  ::Protocol::SCharacterAppearance* temp = _impl_.appearance_;
  _impl_.appearance_ = nullptr;
  return temp;
}
inline ::Protocol::SCharacterAppearance* SCharacterData::_internal_mutable_appearance() {
  
  if (_impl_.appearance_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SCharacterAppearance>(GetArenaForAllocation());
    _impl_.appearance_ = p;
  }
  return _impl_.appearance_;
}
inline ::Protocol::SCharacterAppearance* SCharacterData::mutable_appearance() {
  ::Protocol::SCharacterAppearance* _msg = _internal_mutable_appearance();
  // @@protoc_insertion_point(field_mutable:Protocol.SCharacterData.appearance)
  return _msg;
}
inline void SCharacterData::set_allocated_appearance(::Protocol::SCharacterAppearance* appearance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.appearance_;
  }
  if (appearance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(appearance);
    if (message_arena != submessage_arena) {
      appearance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, appearance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.appearance_ = appearance;
  // @@protoc_insertion_point(field_set_allocated:Protocol.SCharacterData.appearance)
}

// .Protocol.SCharacterEqipment eqipment = 6;
inline bool SCharacterData::_internal_has_eqipment() const {
  return this != internal_default_instance() && _impl_.eqipment_ != nullptr;
}
inline bool SCharacterData::has_eqipment() const {
  return _internal_has_eqipment();
}
inline void SCharacterData::clear_eqipment() {
  if (GetArenaForAllocation() == nullptr && _impl_.eqipment_ != nullptr) {
    delete _impl_.eqipment_;
  }
  _impl_.eqipment_ = nullptr;
}
inline const ::Protocol::SCharacterEqipment& SCharacterData::_internal_eqipment() const {
  const ::Protocol::SCharacterEqipment* p = _impl_.eqipment_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SCharacterEqipment&>(
      ::Protocol::_SCharacterEqipment_default_instance_);
}
inline const ::Protocol::SCharacterEqipment& SCharacterData::eqipment() const {
  // @@protoc_insertion_point(field_get:Protocol.SCharacterData.eqipment)
  return _internal_eqipment();
}
inline void SCharacterData::unsafe_arena_set_allocated_eqipment(
    ::Protocol::SCharacterEqipment* eqipment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eqipment_);
  }
  _impl_.eqipment_ = eqipment;
  if (eqipment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.SCharacterData.eqipment)
}
inline ::Protocol::SCharacterEqipment* SCharacterData::release_eqipment() {
  
  ::Protocol::SCharacterEqipment* temp = _impl_.eqipment_;
  _impl_.eqipment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::SCharacterEqipment* SCharacterData::unsafe_arena_release_eqipment() {
  // @@protoc_insertion_point(field_release:Protocol.SCharacterData.eqipment)
  
  ::Protocol::SCharacterEqipment* temp = _impl_.eqipment_;
  _impl_.eqipment_ = nullptr;
  return temp;
}
inline ::Protocol::SCharacterEqipment* SCharacterData::_internal_mutable_eqipment() {
  
  if (_impl_.eqipment_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SCharacterEqipment>(GetArenaForAllocation());
    _impl_.eqipment_ = p;
  }
  return _impl_.eqipment_;
}
inline ::Protocol::SCharacterEqipment* SCharacterData::mutable_eqipment() {
  ::Protocol::SCharacterEqipment* _msg = _internal_mutable_eqipment();
  // @@protoc_insertion_point(field_mutable:Protocol.SCharacterData.eqipment)
  return _msg;
}
inline void SCharacterData::set_allocated_eqipment(::Protocol::SCharacterEqipment* eqipment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.eqipment_;
  }
  if (eqipment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(eqipment);
    if (message_arena != submessage_arena) {
      eqipment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eqipment, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.eqipment_ = eqipment;
  // @@protoc_insertion_point(field_set_allocated:Protocol.SCharacterData.eqipment)
}

// -------------------------------------------------------------------

// SVector

// float x = 1;
inline void SVector::clear_x() {
  _impl_.x_ = 0;
}
inline float SVector::_internal_x() const {
  return _impl_.x_;
}
inline float SVector::x() const {
  // @@protoc_insertion_point(field_get:Protocol.SVector.x)
  return _internal_x();
}
inline void SVector::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void SVector::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.SVector.x)
}

// float y = 2;
inline void SVector::clear_y() {
  _impl_.y_ = 0;
}
inline float SVector::_internal_y() const {
  return _impl_.y_;
}
inline float SVector::y() const {
  // @@protoc_insertion_point(field_get:Protocol.SVector.y)
  return _internal_y();
}
inline void SVector::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void SVector::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.SVector.y)
}

// float z = 3;
inline void SVector::clear_z() {
  _impl_.z_ = 0;
}
inline float SVector::_internal_z() const {
  return _impl_.z_;
}
inline float SVector::z() const {
  // @@protoc_insertion_point(field_get:Protocol.SVector.z)
  return _internal_z();
}
inline void SVector::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void SVector::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.SVector.z)
}

// -------------------------------------------------------------------

// SVector2D

// int32 x = 1;
inline void SVector2D::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t SVector2D::_internal_x() const {
  return _impl_.x_;
}
inline int32_t SVector2D::x() const {
  // @@protoc_insertion_point(field_get:Protocol.SVector2D.x)
  return _internal_x();
}
inline void SVector2D::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void SVector2D::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.SVector2D.x)
}

// int32 y = 2;
inline void SVector2D::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t SVector2D::_internal_y() const {
  return _impl_.y_;
}
inline int32_t SVector2D::y() const {
  // @@protoc_insertion_point(field_get:Protocol.SVector2D.y)
  return _internal_y();
}
inline void SVector2D::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void SVector2D::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.SVector2D.y)
}

// -------------------------------------------------------------------

// SVelocity

// float x = 1;
inline void SVelocity::clear_x() {
  _impl_.x_ = 0;
}
inline float SVelocity::_internal_x() const {
  return _impl_.x_;
}
inline float SVelocity::x() const {
  // @@protoc_insertion_point(field_get:Protocol.SVelocity.x)
  return _internal_x();
}
inline void SVelocity::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void SVelocity::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.SVelocity.x)
}

// float y = 2;
inline void SVelocity::clear_y() {
  _impl_.y_ = 0;
}
inline float SVelocity::_internal_y() const {
  return _impl_.y_;
}
inline float SVelocity::y() const {
  // @@protoc_insertion_point(field_get:Protocol.SVelocity.y)
  return _internal_y();
}
inline void SVelocity::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void SVelocity::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.SVelocity.y)
}

// float z = 3;
inline void SVelocity::clear_z() {
  _impl_.z_ = 0;
}
inline float SVelocity::_internal_z() const {
  return _impl_.z_;
}
inline float SVelocity::z() const {
  // @@protoc_insertion_point(field_get:Protocol.SVelocity.z)
  return _internal_z();
}
inline void SVelocity::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void SVelocity::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.SVelocity.z)
}

// -------------------------------------------------------------------

// SRotator

// float roll = 1;
inline void SRotator::clear_roll() {
  _impl_.roll_ = 0;
}
inline float SRotator::_internal_roll() const {
  return _impl_.roll_;
}
inline float SRotator::roll() const {
  // @@protoc_insertion_point(field_get:Protocol.SRotator.roll)
  return _internal_roll();
}
inline void SRotator::_internal_set_roll(float value) {
  
  _impl_.roll_ = value;
}
inline void SRotator::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:Protocol.SRotator.roll)
}

// float pitch = 2;
inline void SRotator::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float SRotator::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float SRotator::pitch() const {
  // @@protoc_insertion_point(field_get:Protocol.SRotator.pitch)
  return _internal_pitch();
}
inline void SRotator::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void SRotator::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:Protocol.SRotator.pitch)
}

// float yaw = 3;
inline void SRotator::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float SRotator::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float SRotator::yaw() const {
  // @@protoc_insertion_point(field_get:Protocol.SRotator.yaw)
  return _internal_yaw();
}
inline void SRotator::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void SRotator::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:Protocol.SRotator.yaw)
}

// -------------------------------------------------------------------

// STransform

// .Protocol.SVector location = 1;
inline bool STransform::_internal_has_location() const {
  return this != internal_default_instance() && _impl_.location_ != nullptr;
}
inline bool STransform::has_location() const {
  return _internal_has_location();
}
inline void STransform::clear_location() {
  if (GetArenaForAllocation() == nullptr && _impl_.location_ != nullptr) {
    delete _impl_.location_;
  }
  _impl_.location_ = nullptr;
}
inline const ::Protocol::SVector& STransform::_internal_location() const {
  const ::Protocol::SVector* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SVector&>(
      ::Protocol::_SVector_default_instance_);
}
inline const ::Protocol::SVector& STransform::location() const {
  // @@protoc_insertion_point(field_get:Protocol.STransform.location)
  return _internal_location();
}
inline void STransform::unsafe_arena_set_allocated_location(
    ::Protocol::SVector* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.STransform.location)
}
inline ::Protocol::SVector* STransform::release_location() {
  
  ::Protocol::SVector* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::SVector* STransform::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:Protocol.STransform.location)
  
  ::Protocol::SVector* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::Protocol::SVector* STransform::_internal_mutable_location() {
  
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SVector>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::Protocol::SVector* STransform::mutable_location() {
  ::Protocol::SVector* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:Protocol.STransform.location)
  return _msg;
}
inline void STransform::set_allocated_location(::Protocol::SVector* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:Protocol.STransform.location)
}

// .Protocol.SRotator rotation = 2;
inline bool STransform::_internal_has_rotation() const {
  return this != internal_default_instance() && _impl_.rotation_ != nullptr;
}
inline bool STransform::has_rotation() const {
  return _internal_has_rotation();
}
inline void STransform::clear_rotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
}
inline const ::Protocol::SRotator& STransform::_internal_rotation() const {
  const ::Protocol::SRotator* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SRotator&>(
      ::Protocol::_SRotator_default_instance_);
}
inline const ::Protocol::SRotator& STransform::rotation() const {
  // @@protoc_insertion_point(field_get:Protocol.STransform.rotation)
  return _internal_rotation();
}
inline void STransform::unsafe_arena_set_allocated_rotation(
    ::Protocol::SRotator* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.STransform.rotation)
}
inline ::Protocol::SRotator* STransform::release_rotation() {
  
  ::Protocol::SRotator* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::SRotator* STransform::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:Protocol.STransform.rotation)
  
  ::Protocol::SRotator* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::Protocol::SRotator* STransform::_internal_mutable_rotation() {
  
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SRotator>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::Protocol::SRotator* STransform::mutable_rotation() {
  ::Protocol::SRotator* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:Protocol.STransform.rotation)
  return _msg;
}
inline void STransform::set_allocated_rotation(::Protocol::SRotator* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:Protocol.STransform.rotation)
}

// .Protocol.SVector scale = 3;
inline bool STransform::_internal_has_scale() const {
  return this != internal_default_instance() && _impl_.scale_ != nullptr;
}
inline bool STransform::has_scale() const {
  return _internal_has_scale();
}
inline void STransform::clear_scale() {
  if (GetArenaForAllocation() == nullptr && _impl_.scale_ != nullptr) {
    delete _impl_.scale_;
  }
  _impl_.scale_ = nullptr;
}
inline const ::Protocol::SVector& STransform::_internal_scale() const {
  const ::Protocol::SVector* p = _impl_.scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SVector&>(
      ::Protocol::_SVector_default_instance_);
}
inline const ::Protocol::SVector& STransform::scale() const {
  // @@protoc_insertion_point(field_get:Protocol.STransform.scale)
  return _internal_scale();
}
inline void STransform::unsafe_arena_set_allocated_scale(
    ::Protocol::SVector* scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scale_);
  }
  _impl_.scale_ = scale;
  if (scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.STransform.scale)
}
inline ::Protocol::SVector* STransform::release_scale() {
  
  ::Protocol::SVector* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::SVector* STransform::unsafe_arena_release_scale() {
  // @@protoc_insertion_point(field_release:Protocol.STransform.scale)
  
  ::Protocol::SVector* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
  return temp;
}
inline ::Protocol::SVector* STransform::_internal_mutable_scale() {
  
  if (_impl_.scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SVector>(GetArenaForAllocation());
    _impl_.scale_ = p;
  }
  return _impl_.scale_;
}
inline ::Protocol::SVector* STransform::mutable_scale() {
  ::Protocol::SVector* _msg = _internal_mutable_scale();
  // @@protoc_insertion_point(field_mutable:Protocol.STransform.scale)
  return _msg;
}
inline void STransform::set_allocated_scale(::Protocol::SVector* scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.scale_;
  }
  if (scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scale);
    if (message_arena != submessage_arena) {
      scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.scale_ = scale;
  // @@protoc_insertion_point(field_set_allocated:Protocol.STransform.scale)
}

// -------------------------------------------------------------------

// SItem

// int64 object_id = 1;
inline void SItem::clear_object_id() {
  _impl_.object_id_ = int64_t{0};
}
inline int64_t SItem::_internal_object_id() const {
  return _impl_.object_id_;
}
inline int64_t SItem::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.SItem.object_id)
  return _internal_object_id();
}
inline void SItem::_internal_set_object_id(int64_t value) {
  
  _impl_.object_id_ = value;
}
inline void SItem::set_object_id(int64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.SItem.object_id)
}

// int32 item_code = 2;
inline void SItem::clear_item_code() {
  _impl_.item_code_ = 0;
}
inline int32_t SItem::_internal_item_code() const {
  return _impl_.item_code_;
}
inline int32_t SItem::item_code() const {
  // @@protoc_insertion_point(field_get:Protocol.SItem.item_code)
  return _internal_item_code();
}
inline void SItem::_internal_set_item_code(int32_t value) {
  
  _impl_.item_code_ = value;
}
inline void SItem::set_item_code(int32_t value) {
  _internal_set_item_code(value);
  // @@protoc_insertion_point(field_set:Protocol.SItem.item_code)
}

// .Protocol.SVector world_position = 3;
inline bool SItem::_internal_has_world_position() const {
  return this != internal_default_instance() && _impl_.world_position_ != nullptr;
}
inline bool SItem::has_world_position() const {
  return _internal_has_world_position();
}
inline void SItem::clear_world_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.world_position_ != nullptr) {
    delete _impl_.world_position_;
  }
  _impl_.world_position_ = nullptr;
}
inline const ::Protocol::SVector& SItem::_internal_world_position() const {
  const ::Protocol::SVector* p = _impl_.world_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SVector&>(
      ::Protocol::_SVector_default_instance_);
}
inline const ::Protocol::SVector& SItem::world_position() const {
  // @@protoc_insertion_point(field_get:Protocol.SItem.world_position)
  return _internal_world_position();
}
inline void SItem::unsafe_arena_set_allocated_world_position(
    ::Protocol::SVector* world_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.world_position_);
  }
  _impl_.world_position_ = world_position;
  if (world_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.SItem.world_position)
}
inline ::Protocol::SVector* SItem::release_world_position() {
  
  ::Protocol::SVector* temp = _impl_.world_position_;
  _impl_.world_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::SVector* SItem::unsafe_arena_release_world_position() {
  // @@protoc_insertion_point(field_release:Protocol.SItem.world_position)
  
  ::Protocol::SVector* temp = _impl_.world_position_;
  _impl_.world_position_ = nullptr;
  return temp;
}
inline ::Protocol::SVector* SItem::_internal_mutable_world_position() {
  
  if (_impl_.world_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SVector>(GetArenaForAllocation());
    _impl_.world_position_ = p;
  }
  return _impl_.world_position_;
}
inline ::Protocol::SVector* SItem::mutable_world_position() {
  ::Protocol::SVector* _msg = _internal_mutable_world_position();
  // @@protoc_insertion_point(field_mutable:Protocol.SItem.world_position)
  return _msg;
}
inline void SItem::set_allocated_world_position(::Protocol::SVector* world_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.world_position_;
  }
  if (world_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(world_position);
    if (message_arena != submessage_arena) {
      world_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, world_position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.world_position_ = world_position;
  // @@protoc_insertion_point(field_set_allocated:Protocol.SItem.world_position)
}

// .Protocol.SVector2D inven_position = 4;
inline bool SItem::_internal_has_inven_position() const {
  return this != internal_default_instance() && _impl_.inven_position_ != nullptr;
}
inline bool SItem::has_inven_position() const {
  return _internal_has_inven_position();
}
inline void SItem::clear_inven_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.inven_position_ != nullptr) {
    delete _impl_.inven_position_;
  }
  _impl_.inven_position_ = nullptr;
}
inline const ::Protocol::SVector2D& SItem::_internal_inven_position() const {
  const ::Protocol::SVector2D* p = _impl_.inven_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::SVector2D&>(
      ::Protocol::_SVector2D_default_instance_);
}
inline const ::Protocol::SVector2D& SItem::inven_position() const {
  // @@protoc_insertion_point(field_get:Protocol.SItem.inven_position)
  return _internal_inven_position();
}
inline void SItem::unsafe_arena_set_allocated_inven_position(
    ::Protocol::SVector2D* inven_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inven_position_);
  }
  _impl_.inven_position_ = inven_position;
  if (inven_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.SItem.inven_position)
}
inline ::Protocol::SVector2D* SItem::release_inven_position() {
  
  ::Protocol::SVector2D* temp = _impl_.inven_position_;
  _impl_.inven_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::SVector2D* SItem::unsafe_arena_release_inven_position() {
  // @@protoc_insertion_point(field_release:Protocol.SItem.inven_position)
  
  ::Protocol::SVector2D* temp = _impl_.inven_position_;
  _impl_.inven_position_ = nullptr;
  return temp;
}
inline ::Protocol::SVector2D* SItem::_internal_mutable_inven_position() {
  
  if (_impl_.inven_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::SVector2D>(GetArenaForAllocation());
    _impl_.inven_position_ = p;
  }
  return _impl_.inven_position_;
}
inline ::Protocol::SVector2D* SItem::mutable_inven_position() {
  ::Protocol::SVector2D* _msg = _internal_mutable_inven_position();
  // @@protoc_insertion_point(field_mutable:Protocol.SItem.inven_position)
  return _msg;
}
inline void SItem::set_allocated_inven_position(::Protocol::SVector2D* inven_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inven_position_;
  }
  if (inven_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inven_position);
    if (message_arena != submessage_arena) {
      inven_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inven_position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.inven_position_ = inven_position;
  // @@protoc_insertion_point(field_set_allocated:Protocol.SItem.inven_position)
}

// int32 rotation = 5;
inline void SItem::clear_rotation() {
  _impl_.rotation_ = 0;
}
inline int32_t SItem::_internal_rotation() const {
  return _impl_.rotation_;
}
inline int32_t SItem::rotation() const {
  // @@protoc_insertion_point(field_get:Protocol.SItem.rotation)
  return _internal_rotation();
}
inline void SItem::_internal_set_rotation(int32_t value) {
  
  _impl_.rotation_ = value;
}
inline void SItem::set_rotation(int32_t value) {
  _internal_set_rotation(value);
  // @@protoc_insertion_point(field_set:Protocol.SItem.rotation)
}

// int32 amount = 6;
inline void SItem::clear_amount() {
  _impl_.amount_ = 0;
}
inline int32_t SItem::_internal_amount() const {
  return _impl_.amount_;
}
inline int32_t SItem::amount() const {
  // @@protoc_insertion_point(field_get:Protocol.SItem.amount)
  return _internal_amount();
}
inline void SItem::_internal_set_amount(int32_t value) {
  
  _impl_.amount_ = value;
}
inline void SItem::set_amount(int32_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:Protocol.SItem.amount)
}

// -------------------------------------------------------------------

// SStat

// .Protocol.EStatType stat_type = 1;
inline void SStat::clear_stat_type() {
  _impl_.stat_type_ = 0;
}
inline ::Protocol::EStatType SStat::_internal_stat_type() const {
  return static_cast< ::Protocol::EStatType >(_impl_.stat_type_);
}
inline ::Protocol::EStatType SStat::stat_type() const {
  // @@protoc_insertion_point(field_get:Protocol.SStat.stat_type)
  return _internal_stat_type();
}
inline void SStat::_internal_set_stat_type(::Protocol::EStatType value) {
  
  _impl_.stat_type_ = value;
}
inline void SStat::set_stat_type(::Protocol::EStatType value) {
  _internal_set_stat_type(value);
  // @@protoc_insertion_point(field_set:Protocol.SStat.stat_type)
}

// float stat_value = 2;
inline void SStat::clear_stat_value() {
  _impl_.stat_value_ = 0;
}
inline float SStat::_internal_stat_value() const {
  return _impl_.stat_value_;
}
inline float SStat::stat_value() const {
  // @@protoc_insertion_point(field_get:Protocol.SStat.stat_value)
  return _internal_stat_value();
}
inline void SStat::_internal_set_stat_value(float value) {
  
  _impl_.stat_value_ = value;
}
inline void SStat::set_stat_value(float value) {
  _internal_set_stat_value(value);
  // @@protoc_insertion_point(field_set:Protocol.SStat.stat_value)
}

// -------------------------------------------------------------------

// SFriend

// bytes nick_name = 1;
inline void SFriend::clear_nick_name() {
  _impl_.nick_name_.ClearToEmpty();
}
inline const std::string& SFriend::nick_name() const {
  // @@protoc_insertion_point(field_get:Protocol.SFriend.nick_name)
  return _internal_nick_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SFriend::set_nick_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nick_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.SFriend.nick_name)
}
inline std::string* SFriend::mutable_nick_name() {
  std::string* _s = _internal_mutable_nick_name();
  // @@protoc_insertion_point(field_mutable:Protocol.SFriend.nick_name)
  return _s;
}
inline const std::string& SFriend::_internal_nick_name() const {
  return _impl_.nick_name_.Get();
}
inline void SFriend::_internal_set_nick_name(const std::string& value) {
  
  _impl_.nick_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SFriend::_internal_mutable_nick_name() {
  
  return _impl_.nick_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SFriend::release_nick_name() {
  // @@protoc_insertion_point(field_release:Protocol.SFriend.nick_name)
  return _impl_.nick_name_.Release();
}
inline void SFriend::set_allocated_nick_name(std::string* nick_name) {
  if (nick_name != nullptr) {
    
  } else {
    
  }
  _impl_.nick_name_.SetAllocated(nick_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nick_name_.IsDefault()) {
    _impl_.nick_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.SFriend.nick_name)
}

// int32 level = 2;
inline void SFriend::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t SFriend::_internal_level() const {
  return _impl_.level_;
}
inline int32_t SFriend::level() const {
  // @@protoc_insertion_point(field_get:Protocol.SFriend.level)
  return _internal_level();
}
inline void SFriend::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void SFriend::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.SFriend.level)
}

// .Protocol.ECharacterClass character_class = 3;
inline void SFriend::clear_character_class() {
  _impl_.character_class_ = 0;
}
inline ::Protocol::ECharacterClass SFriend::_internal_character_class() const {
  return static_cast< ::Protocol::ECharacterClass >(_impl_.character_class_);
}
inline ::Protocol::ECharacterClass SFriend::character_class() const {
  // @@protoc_insertion_point(field_get:Protocol.SFriend.character_class)
  return _internal_character_class();
}
inline void SFriend::_internal_set_character_class(::Protocol::ECharacterClass value) {
  
  _impl_.character_class_ = value;
}
inline void SFriend::set_character_class(::Protocol::ECharacterClass value) {
  _internal_set_character_class(value);
  // @@protoc_insertion_point(field_set:Protocol.SFriend.character_class)
}

// int32 locale = 4;
inline void SFriend::clear_locale() {
  _impl_.locale_ = 0;
}
inline int32_t SFriend::_internal_locale() const {
  return _impl_.locale_;
}
inline int32_t SFriend::locale() const {
  // @@protoc_insertion_point(field_get:Protocol.SFriend.locale)
  return _internal_locale();
}
inline void SFriend::_internal_set_locale(int32_t value) {
  
  _impl_.locale_ = value;
}
inline void SFriend::set_locale(int32_t value) {
  _internal_set_locale(value);
  // @@protoc_insertion_point(field_set:Protocol.SFriend.locale)
}

// int32 state = 5;
inline void SFriend::clear_state() {
  _impl_.state_ = 0;
}
inline int32_t SFriend::_internal_state() const {
  return _impl_.state_;
}
inline int32_t SFriend::state() const {
  // @@protoc_insertion_point(field_get:Protocol.SFriend.state)
  return _internal_state();
}
inline void SFriend::_internal_set_state(int32_t value) {
  
  _impl_.state_ = value;
}
inline void SFriend::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Protocol.SFriend.state)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_PacketStruct_2eproto
